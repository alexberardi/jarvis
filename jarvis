#!/usr/bin/env bash
# Jarvis service orchestration CLI
# Usage: ./jarvis <command> [service|--all] [options]
#
# Commands:
#   quickstart                  Full setup: init + start + LLM wizard
#   init                        Generate tokens, create .env files, start infra, run migrations
#   start [service|--all]       Start service(s) in dependency order
#   stop [service|--all]        Stop service(s) in reverse order
#   restart [service|--all]     Stop then start
#   rebuild [service|--all]     Rebuild Docker images and restart
#   status                      Show all service statuses
#   health                      Hit health endpoints
#   logs <service>              Tail Docker logs for a service
#   doctor                      Run system diagnostics
#
# Options:
#   --standalone                Start service with its own postgres (solo dev)
#   --no-network                Skip jarvis-net, use host.docker.internal (distributed mode)
#   --force                     Force overwrite .env files during init
#   --custom                    Prompt for custom database names during init

set -e

JARVIS_ROOT="$(cd "$(dirname "$0")" && pwd)"
PID_DIR="${HOME}/.jarvis/pids"
LOG_DIR="${HOME}/.jarvis/logs"
TOKEN_DIR="${HOME}/.jarvis"
TOKEN_FILE="${TOKEN_DIR}/tokens.env"
DB_FILE="${TOKEN_DIR}/databases.env"
DATA_SERVICES_DIR="${JARVIS_ROOT}/jarvis-data-services"
DATA_SERVICES_ENV="${DATA_SERVICES_DIR}/.env"
mkdir -p "$PID_DIR" "$LOG_DIR"

# ── Network mode ───────────────────────────────────────────────────────────
NETWORK_MODE="${JARVIS_NETWORK_MODE:-bridge}"

# ── Service registry ────────────────────────────────────────────────────────
# Format: "name|port|tier|mode|health_path"
# mode: docker or local
# tier: startup order (0 = first)
SERVICES=(
    "jarvis-config-service|7700|0|docker|/health"
    "jarvis-auth|7701|1|docker|/health"
    "jarvis-logs|7702|1|docker|/health"
    "jarvis-command-center|7703|2|docker|/health"
    "jarvis-llm-proxy-api|7704|2|docker|/health"
    "jarvis-tts|7707|3|docker|/health"
    "jarvis-whisper-api|7706|3|docker|/health"
    "jarvis-ocr-service|7031|3|docker|/health"
    "jarvis-recipes-server|7030|3|docker|/health"
    "jarvis-settings-server|7708|4|docker|/health"
    "jarvis-mcp|7709|4|docker|/health"
    "jarvis-admin|7710|5|npm|/"
)

# macOS overrides: GPU services run locally for Metal/Apple Vision
if [[ "$(uname -s)" == "Darwin" ]]; then
    for i in "${!SERVICES[@]}"; do
        case "${SERVICES[$i]}" in
            jarvis-llm-proxy-api*) SERVICES[$i]="jarvis-llm-proxy-api|7704|2|local|/health" ;;
            jarvis-ocr-service*)   SERVICES[$i]="jarvis-ocr-service|7031|3|local|/health" ;;
        esac
    done
fi

# ── Database mapping ─────────────────────────────────────────────────────────
# Consolidated database config: "service_name|db_var|default_db_name|env_vars"
# No associative arrays — bash 3.2 (macOS default) doesn't support them.
DB_ENTRIES=(
    "jarvis-config-service|DB_NAME_CONFIG|jarvis_config|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-auth|DB_NAME_AUTH|jarvis_auth|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-logs|DB_NAME_LOGS|jarvis_logs|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-command-center|DB_NAME_COMMAND_CENTER|jarvis_command_center|DB_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-llm-proxy-api|DB_NAME_LLM_PROXY|jarvis_llm_proxy|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-tts|DB_NAME_TTS|jarvis_tts|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-whisper-api|DB_NAME_WHISPER|jarvis_whisper|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-ocr-service|DB_NAME_OCR|jarvis_ocr|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-recipes-server|DB_NAME_RECIPES|jarvis_recipes|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-mcp|DB_NAME_MCP|jarvis_mcp|DATABASE_URL,MIGRATIONS_DATABASE_URL"
)

# Lookup helpers for DB_ENTRIES (field positions: 1=service, 2=var, 3=default, 4=env_vars)
_db_entry_for_service() {
    local svc="$1"
    for entry in "${DB_ENTRIES[@]}"; do
        if [[ "${entry%%|*}" == "$svc" ]]; then
            echo "$entry"
            return 0
        fi
    done
    return 1
}

_db_field() { echo "$1" | cut -d'|' -f"$2"; }

# Services with migrations (in tier order, matches reset_all_databases.sh)
SERVICES_WITH_MIGRATIONS=(
    "jarvis-config-service"
    "jarvis-auth"
    "jarvis-logs"
    "jarvis-command-center"
    "jarvis-llm-proxy-api"
    "jarvis-tts"
    "jarvis-whisper-api"
    "jarvis-ocr-service"
    "jarvis-recipes-server"
    "jarvis-mcp"
)

# Services that use Redis
REDIS_SERVICES=(
    "jarvis-llm-proxy-api"
    "jarvis-ocr-service"
    "jarvis-recipes-server"
)

# ── LLM Model Catalog ─────────────────────────────────────────────────────────
# Format: "display_name|hf_repo_vllm|hf_repo_gguf|gguf_filename|chat_format|context_window|size_vllm|size_gguf|vram_mb|gated|quantization"
# vLLM repos use AWQ 4-bit quantization; GGUF repos use Q4_K_M.
# vram_mb = minimum VRAM (MB) needed for vLLM to load the AWQ model.
LLM_MODELS=(
    "Qwen 3 4B|Qwen/Qwen3-4B-AWQ|bartowski/Qwen3-4B-GGUF|Qwen3-4B-Q4_K_M.gguf|qwen3|40960|2.5GB|2.5GB|4096|no|awq"
    "Llama 3.2 3B Instruct|AMead10/Llama-3.2-3B-Instruct-AWQ|bartowski/Llama-3.2-3B-Instruct-GGUF|Llama-3.2-3B-Instruct-Q4_K_M.gguf|llama3|131072|2.9GB|2GB|4096|yes|awq"
    "Qwen 3 8B|Qwen/Qwen3-8B-AWQ|bartowski/Qwen3-8B-GGUF|Qwen3-8B-Q4_K_M.gguf|qwen3|40960|5.7GB|5GB|7168|no|awq"
    "Llama 3.1 8B Instruct|hugging-quants/Meta-Llama-3.1-8B-Instruct-AWQ-INT4|bartowski/Meta-Llama-3.1-8B-Instruct-GGUF|Meta-Llama-3.1-8B-Instruct-Q4_K_M.gguf|llama3|131072|5.4GB|5GB|7168|yes|awq"
    "Mistral Nemo 12B|casperhansen/mistral-nemo-instruct-2407-awq|bartowski/Mistral-Nemo-Instruct-2407-GGUF|Mistral-Nemo-Instruct-2407-Q4_K_M.gguf|mistral|131072|7.8GB|7GB|10240|no|awq"
    "Qwen 3 14B|Qwen/Qwen3-14B-AWQ|bartowski/Qwen3-14B-GGUF|Qwen3-14B-Q4_K_M.gguf|qwen3|40960|9.4GB|9GB|12288|no|awq"
)

# ── Colors ───────────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ── Helpers ──────────────────────────────────────────────────────────────────

_parse_field() {
    local entry="$1" field="$2"
    echo "$entry" | cut -d'|' -f"$field"
}

_get_name()   { _parse_field "$1" 1; }
_get_port()   { _parse_field "$1" 2; }
_get_tier()   { _parse_field "$1" 3; }
_get_mode()   { _parse_field "$1" 4; }
_get_health() { _parse_field "$1" 5; }

_kill_tree() {
    # Kill a process and all its descendants
    local pid="$1"
    [[ -z "$pid" ]] && return 0
    kill -0 "$pid" 2>/dev/null || return 0

    # Kill children first (recursive)
    local children
    children=$(pgrep -P "$pid" 2>/dev/null || true)
    for child in $children; do
        _kill_tree "$child"
    done

    kill "$pid" 2>/dev/null || true
}

_find_service() {
    local target="$1"
    for entry in "${SERVICES[@]}"; do
        local name
        name=$(_get_name "$entry")
        if [[ "$name" == "$target" ]]; then
            echo "$entry"
            return 0
        fi
    done
    return 1
}

_services_by_tier() {
    local order="$1"  # asc or desc
    local sorted
    if [[ "$order" == "desc" ]]; then
        sorted=$(for entry in "${SERVICES[@]}"; do
            echo "$(_get_tier "$entry")|$entry"
        done | sort -t'|' -k1 -rn)
    else
        sorted=$(for entry in "${SERVICES[@]}"; do
            echo "$(_get_tier "$entry")|$entry"
        done | sort -t'|' -k1 -n)
    fi

    while IFS= read -r line; do
        # Strip the leading tier field we added for sorting
        echo "${line#*|}"
    done <<< "$sorted"
}

_wait_for_health() {
    local name="$1" port="$2" health_path="$3" timeout="${4:-30}"
    local elapsed=0
    while (( elapsed < timeout )); do
        if curl -sf --max-time 2 "http://localhost:${port}${health_path}" >/dev/null 2>&1; then
            return 0
        fi
        sleep 1
        elapsed=$((elapsed + 1))
    done
    return 1
}

_find_compose_file() {
    local dir="$1"
    if [[ -f "$dir/docker-compose.dev.yaml" ]]; then
        echo "docker-compose.dev.yaml"
    elif [[ -f "$dir/docker-compose.yml" ]]; then
        echo "docker-compose.yml"
    elif [[ -f "$dir/docker-compose.yaml" ]]; then
        echo "docker-compose.yaml"
    fi
}

_get_compose_flags() {
    local dir="$1"
    local compose_file
    compose_file=$(_find_compose_file "$dir")
    [[ -z "$compose_file" ]] && return 1

    local flags="-f $compose_file"

    # In bridge mode, overlay the jarvis-net network
    if [[ "$NETWORK_MODE" == "bridge" ]] && [[ -f "${JARVIS_ROOT}/.jarvis-net-override.yaml" ]]; then
        flags="$flags -f ${JARVIS_ROOT}/.jarvis-net-override.yaml"
    fi

    echo "$flags"
}

_write_network_override() {
    # Ensure the jarvis-net Docker network exists
    docker network create jarvis-net >/dev/null 2>&1 || true

    # Write the jarvis-net overlay file (used in bridge mode)
    cat > "${JARVIS_ROOT}/.jarvis-net-override.yaml" << 'YAML'
# Auto-generated by ./jarvis CLI — do not edit
# Attaches services to the shared jarvis-net network
networks:
  default:
    name: jarvis-net
    external: true
YAML
}

_get_redis_password() {
    # Read redis password from data-services.env
    if [[ -f "$DATA_SERVICES_ENV" ]]; then
        grep "^REDIS_PASSWORD=" "$DATA_SERVICES_ENV" 2>/dev/null | cut -d= -f2-
    else
        echo "redis"  # default
    fi
}

# ── Database names ────────────────────────────────────────────────────────────

_write_db_defaults() {
    # Write databases.env with default names (skip if exists and not --force)
    if [[ -f "$DB_FILE" ]] && [[ "$FORCE_INIT" != true ]]; then
        echo -e "  ${GREEN}OK${NC}    Database names already configured (${DB_FILE})"
        return 0
    fi

    mkdir -p "$TOKEN_DIR"

    {
        echo "# Jarvis database names — generated by ./jarvis init"
        echo "# Edit these to use custom database names, then re-run ./jarvis init"
        for entry in "${DB_ENTRIES[@]}"; do
            local var default_val
            var=$(_db_field "$entry" 2)
            default_val=$(_db_field "$entry" 3)
            echo "${var}=${default_val}"
        done
    } > "$DB_FILE"

    chmod 600 "$DB_FILE"
    echo -e "  ${GREEN}OK${NC}    Database names → ${DB_FILE}"
}

_prompt_db_names() {
    # Interactive prompt for custom database names
    mkdir -p "$TOKEN_DIR"

    echo -e "  ${DIM}Database names (press Enter for defaults):${NC}"

    # Load existing values as defaults (if databases.env exists)
    if [[ -f "$DB_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$DB_FILE"
    fi

    local output=""
    for entry in "${DB_ENTRIES[@]}"; do
        local var label default_val current
        var=$(_db_field "$entry" 2)
        label=$(_db_field "$entry" 1)
        default_val=$(_db_field "$entry" 3)
        current="${!var:-${default_val}}"

        printf "    %-28s [%s]: " "$label" "$current"
        local user_input
        read -r user_input

        local value="${user_input:-$current}"
        # Validate: alphanumeric and underscore only
        if [[ ! "$value" =~ ^[A-Za-z0-9_]+$ ]]; then
            echo -e "    ${RED}Invalid name (alphanumeric/underscore only). Using default.${NC}"
            value="${default_val}"
        fi

        output+="${var}=${value}\n"
    done

    printf "# Jarvis database names — generated by ./jarvis init --custom\n" > "$DB_FILE"
    printf "%b" "$output" >> "$DB_FILE"

    chmod 600 "$DB_FILE"
    echo -e "  ${GREEN}OK${NC}    Custom database names → ${DB_FILE}"
}

_load_db_names() {
    # Load database names from databases.env, falling back to defaults
    if [[ -f "$DB_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$DB_FILE"
    else
        # Use defaults (printf -v sets global variables, unlike declare in functions)
        for entry in "${DB_ENTRIES[@]}"; do
            local var default_val
            var=$(_db_field "$entry" 2)
            default_val=$(_db_field "$entry" 3)
            printf -v "$var" '%s' "$default_val"
        done
    fi
}

_get_db_name_for_service() {
    # Get the database name for a given service
    local service_name="$1"
    local db_entry
    db_entry=$(_db_entry_for_service "$service_name") || return 1

    local db_var
    db_var=$(_db_field "$db_entry" 2)

    # Return the value of that variable (loaded by _load_db_names)
    echo "${!db_var}"
}

# ── Init ─────────────────────────────────────────────────────────────────────

_generate_token() {
    openssl rand -hex 32
}

_generate_tokens() {
    if [[ -f "$TOKEN_FILE" ]] && [[ "$FORCE_INIT" != true ]]; then
        echo -e "  ${GREEN}OK${NC}    Tokens already exist (${TOKEN_FILE})"
        return 0
    fi

    mkdir -p "$TOKEN_DIR"

    local jwt_secret auth_admin_token config_admin_token
    local cc_admin_key model_service_token llm_internal_token

    jwt_secret=$(_generate_token)
    auth_admin_token=$(_generate_token)
    config_admin_token=$(_generate_token)
    cc_admin_key=$(_generate_token)
    model_service_token=$(_generate_token)
    llm_internal_token=$(_generate_token)

    cat > "$TOKEN_FILE" << EOF
# Jarvis shared tokens — generated by ./jarvis init
# Master copy. Individual .env files reference these values.
AUTH_SECRET_KEY=${jwt_secret}
JARVIS_AUTH_ADMIN_TOKEN=${auth_admin_token}
JARVIS_CONFIG_ADMIN_TOKEN=${config_admin_token}
ADMIN_API_KEY=${cc_admin_key}
MODEL_SERVICE_TOKEN=${model_service_token}
LLM_PROXY_INTERNAL_TOKEN=${llm_internal_token}
EOF

    chmod 600 "$TOKEN_FILE"
    echo -e "  ${GREEN}OK${NC}    Generated tokens → ${TOKEN_FILE}"
}

_load_tokens() {
    if [[ ! -f "$TOKEN_FILE" ]]; then
        echo -e "  ${RED}FAIL${NC}  No tokens file found. Run: ./jarvis init"
        exit 1
    fi
    # shellcheck disable=SC1090
    source "$TOKEN_FILE"
}

_sed_i() {
    # Cross-platform sed -i (macOS requires '' suffix, Linux does not)
    if [[ "$(uname -s)" == "Darwin" ]]; then
        sed -i '' "$@"
    else
        sed -i "$@"
    fi
}

_inject_env_var() {
    # Inject or replace a variable in a .env file
    local env_file="$1" var_name="$2" var_value="$3"

    if [[ ! -f "$env_file" ]]; then
        echo "${var_name}=${var_value}" >> "$env_file"
        return
    fi

    # Escape sed special characters in the replacement value (& \ |)
    local escaped_value
    escaped_value=$(printf '%s' "$var_value" | sed 's/[&\|]/\\&/g')

    if grep -q "^${var_name}=" "$env_file" 2>/dev/null; then
        # Replace existing value
        _sed_i "s|^${var_name}=.*|${var_name}=${escaped_value}|" "$env_file"
    elif grep -q "^# *${var_name}=" "$env_file" 2>/dev/null; then
        # Uncomment and set
        _sed_i "s|^# *${var_name}=.*|${var_name}=${escaped_value}|" "$env_file"
    else
        # Append
        echo "${var_name}=${var_value}" >> "$env_file"
    fi
}

_stamp_env_files() {
    _load_tokens
    _load_db_names

    for entry in "${SERVICES[@]}"; do
        local name mode
        name=$(_get_name "$entry")
        mode=$(_get_mode "$entry")
        local dir="${JARVIS_ROOT}/${name}"

        [[ ! -d "$dir" ]] && continue

        local env_file="${dir}/.env"
        local env_example="${dir}/.env.example"

        # Copy .env.example (or env.template) -> .env if .env doesn't exist (or --force)
        if [[ ! -f "$env_file" ]] || [[ "$FORCE_INIT" == true ]]; then
            if [[ -f "$env_example" ]]; then
                cp "$env_example" "$env_file"
            elif [[ -f "${dir}/env.template" ]]; then
                cp "${dir}/env.template" "$env_file"
            else
                touch "$env_file"
            fi
        fi

        # Docker services need host.docker.internal; local/npm use localhost
        local svc_host="host.docker.internal"
        if [[ "$mode" == "local" ]] || [[ "$mode" == "npm" ]]; then
            svc_host="localhost"
        fi

        # --- Shared tokens (all services) ---
        _inject_env_var "$env_file" "JARVIS_AUTH_ADMIN_TOKEN" "$JARVIS_AUTH_ADMIN_TOKEN"
        _inject_env_var "$env_file" "JARVIS_CONFIG_URL" "http://${svc_host}:7700"

        # --- Service-specific tokens ---
        case "$name" in
            jarvis-auth)
                _inject_env_var "$env_file" "AUTH_SECRET_KEY" "$AUTH_SECRET_KEY"
                ;;
            jarvis-config-service)
                _inject_env_var "$env_file" "JARVIS_CONFIG_ADMIN_TOKEN" "$JARVIS_CONFIG_ADMIN_TOKEN"
                _inject_env_var "$env_file" "JARVIS_AUTH_URL" "http://${svc_host}:7701"
                _inject_env_var "$env_file" "DOCKER_HOST_GATEWAY" "host.docker.internal"
                _inject_env_var "$env_file" "JARVIS_HOST_ROOT" "$JARVIS_ROOT"
                _inject_env_var "$env_file" "JARVIS_ROOT" "/jarvis"
                ;;
            jarvis-settings-server)
                _inject_env_var "$env_file" "JARVIS_AUTH_SECRET_KEY" "$AUTH_SECRET_KEY"
                ;;
            jarvis-command-center)
                _inject_env_var "$env_file" "ADMIN_API_KEY" "$ADMIN_API_KEY"
                ;;
            jarvis-llm-proxy-api)
                _inject_env_var "$env_file" "MODEL_SERVICE_TOKEN" "$MODEL_SERVICE_TOKEN"
                _inject_env_var "$env_file" "LLM_PROXY_INTERNAL_TOKEN" "$LLM_PROXY_INTERNAL_TOKEN"
                ;;
            jarvis-admin)
                _inject_env_var "$env_file" "PORT" "7711"
                ;;
        esac

        # --- App identity (all services except admin) ---
        # Config-service needs JARVIS_APP_ID for settings gateway (app-to-app auth to other services)
        if [[ "$name" != "jarvis-admin" ]]; then
            _inject_env_var "$env_file" "JARVIS_APP_ID" "$name"
        fi

        # --- Auth service URL (env var fallback for module-level auth init) ---
        if [[ "$name" != "jarvis-auth" && "$name" != "jarvis-config-service" && "$name" != "jarvis-admin" ]]; then
            _inject_env_var "$env_file" "JARVIS_AUTH_BASE_URL" "http://${svc_host}:7701"
        fi

        # --- Redis password (for services that use Redis) ---
        for redis_svc in "${REDIS_SERVICES[@]}"; do
            if [[ "$name" == "$redis_svc" ]]; then
                local redis_pw
                redis_pw=$(_get_redis_password)
                _inject_env_var "$env_file" "REDIS_PASSWORD" "$redis_pw"
                break
            fi
        done

        # --- Database URLs ---
        local db_entry=""
        db_entry=$(_db_entry_for_service "$name") || true
        if [[ -n "$db_entry" ]]; then
            local db_var env_vars db_name
            db_var=$(_db_field "$db_entry" 2)
            env_vars=$(_db_field "$db_entry" 4)
            db_name="${!db_var}"

            # Read postgres credentials from data-services.env (or defaults)
            local pg_user="postgres" pg_pass="postgres"
            if [[ -f "$DATA_SERVICES_ENV" ]]; then
                pg_user=$(grep "^POSTGRES_USER=" "$DATA_SERVICES_ENV" 2>/dev/null | cut -d= -f2-) || pg_user="postgres"
                pg_pass=$(grep "^POSTGRES_PASSWORD=" "$DATA_SERVICES_ENV" 2>/dev/null | cut -d= -f2-) || pg_pass="postgres"
            fi

            local db_url="postgresql+psycopg2://${pg_user}:${pg_pass}@${svc_host}:5432/${db_name}"
            local migrations_url="postgresql+psycopg2://${pg_user}:${pg_pass}@localhost:5432/${db_name}"

            IFS=',' read -ra var_names <<< "$env_vars"
            for var_name in "${var_names[@]}"; do
                if [[ "$var_name" == "MIGRATIONS_DATABASE_URL" ]]; then
                    _inject_env_var "$env_file" "$var_name" "$migrations_url"
                else
                    _inject_env_var "$env_file" "$var_name" "$db_url"
                fi
            done
        fi

        echo -e "  ${GREEN}OK${NC}    ${name}/.env"
    done

    # Stamp ~/.jarvis/admin.json with correct service URLs
    local admin_json="${TOKEN_DIR}/admin.json"
    cat > "$admin_json" << ADMINJSON
{
  "authUrl": "http://localhost:7701",
  "configServiceUrl": "http://localhost:7700",
  "llmProxyUrl": "http://localhost:7704",
  "commandCenterUrl": "http://localhost:7703"
}
ADMINJSON
    echo -e "  ${GREEN}OK${NC}    ~/.jarvis/admin.json"
}

_start_infra() {
    echo -e "\n${DIM}Starting infrastructure (PostgreSQL + Redis + pgAdmin + MinIO)...${NC}"

    if [[ ! -d "$DATA_SERVICES_DIR" ]]; then
        echo -e "  ${RED}FAIL${NC}  jarvis-data-services directory not found"
        echo -e "  ${DIM}Run: git clone git@github.com:alexberardi/jarvis-data-services.git ${DATA_SERVICES_DIR}${NC}"
        exit 1
    fi

    # Create default .env if missing (gitignored, required by docker-compose)
    if [[ ! -f "$DATA_SERVICES_ENV" ]]; then
        cat > "$DATA_SERVICES_ENV" <<'ENVEOF'
POSTGRES_USER=postgres
POSTGRES_PASSWORD=postgres
POSTGRES_DB=app
POSTGRES_PORT=5432

PGADMIN_DEFAULT_EMAIL=admin@example.com
PGADMIN_DEFAULT_PASSWORD=admin
PGADMIN_PORT=5050

MINIO_ROOT_USER=minioadmin
MINIO_ROOT_PASSWORD=minioadmin
MINIO_PORT=9000
MINIO_CONSOLE_PORT=9001

REDIS_PASSWORD=redis
REDIS_PORT=6379
REDIS_COMMANDER_PORT=8081
ENVEOF
        echo -e "  ${GREEN}OK${NC}    Created data-services .env (defaults)"
    fi

    local compose_output
    if ! compose_output=$(cd "$DATA_SERVICES_DIR" && docker compose --env-file .env up -d 2>&1); then
        echo -e "  ${RED}FAIL${NC}  docker compose up failed for jarvis-data-services"
        echo -e "  ${DIM}${compose_output}${NC}"
        exit 1
    fi

    # Wait for postgres health
    local elapsed=0
    while (( elapsed < 30 )); do
        if docker exec jarvis-postgres pg_isready -U postgres >/dev/null 2>&1; then
            echo -e "  ${GREEN}OK${NC}    PostgreSQL ready"
            break
        fi
        sleep 1
        elapsed=$((elapsed + 1))
    done

    if (( elapsed >= 30 )); then
        echo -e "  ${RED}FAIL${NC}  PostgreSQL did not become ready in 30s"
        exit 1
    fi

    # Wait for redis health
    local redis_pw
    redis_pw=$(_get_redis_password)
    elapsed=0
    while (( elapsed < 15 )); do
        if docker exec jarvis-redis redis-cli -a "$redis_pw" ping >/dev/null 2>&1; then
            echo -e "  ${GREEN}OK${NC}    Redis ready"
            break
        fi
        sleep 1
        elapsed=$((elapsed + 1))
    done

    if (( elapsed >= 15 )); then
        echo -e "  ${YELLOW}WARN${NC}  Redis did not become ready in 15s (non-fatal)"
    fi
}

_create_databases() {
    echo -e "\n${DIM}Creating databases...${NC}"

    _load_db_names

    if [[ ! -f "${DATA_SERVICES_DIR}/create-db.sh" ]]; then
        echo -e "  ${YELLOW}WARN${NC}  create-db.sh not found in jarvis-data-services, skipping"
        return 0
    fi

    for entry in "${DB_ENTRIES[@]}"; do
        local var label db_name
        var=$(_db_field "$entry" 2)
        label=$(_db_field "$entry" 1)
        db_name="${!var}"

        local db_output
        if db_output=$(cd "$DATA_SERVICES_DIR" && bash create-db.sh "$db_name" 2>&1); then
            echo -e "  ${GREEN}OK${NC}    ${db_name} (${label})"
        else
            # create-db.sh exits 0 for "already exists", so failure is real
            echo -e "  ${RED}FAIL${NC}  ${db_name} (${label})"
            echo "$db_output" | tail -3 | while IFS= read -r line; do
                echo -e "        ${DIM}${line}${NC}"
            done
        fi
    done
}

_run_migrations() {
    echo -e "\n${DIM}Running migrations...${NC}"

    local success=0
    local failed=0

    for service in "${SERVICES_WITH_MIGRATIONS[@]}"; do
        local service_dir="${JARVIS_ROOT}/${service}"
        local migration_script="${service_dir}/apply_migrations.sh"

        if [[ ! -f "$migration_script" ]]; then
            echo -e "  ${YELLOW}SKIP${NC}  ${service} (no apply_migrations.sh)"
            continue
        fi

        if [[ ! -x "${service_dir}/.venv/bin/python" ]] && [[ ! -x "${service_dir}/venv/bin/python" ]]; then
            # Bootstrap a venv so migrations can run
            echo -ne "  ${BLUE}...${NC}   ${service} (creating .venv for migrations)"
            local venv_output
            if venv_output=$(cd "$service_dir" && python3 -m venv .venv && .venv/bin/pip install -e . 2>&1); then
                echo -e "\r  ${GREEN}OK${NC}    ${service} (.venv created)\033[K"
            else
                echo -e "\r  ${YELLOW}SKIP${NC}  ${service} (venv setup failed)\033[K"
                echo "$venv_output" | tail -3 | while IFS= read -r line; do
                    echo -e "        ${DIM}${line}${NC}"
                done
                failed=$((failed + 1))
                continue
            fi
        fi

        local migration_output
        if migration_output=$(cd "$service_dir" && bash apply_migrations.sh 2>&1); then
            echo -e "  ${GREEN}OK${NC}    ${service}"
            success=$((success + 1))
        else
            echo -e "  ${RED}FAIL${NC}  ${service}"
            echo "$migration_output" | tail -3 | while IFS= read -r line; do
                echo -e "        ${DIM}${line}${NC}"
            done
            failed=$((failed + 1))
        fi
    done

    echo -e "\n  Migrations: ${GREEN}${success} OK${NC}, ${RED}${failed} failed${NC}"
}

_setup_local_services() {
    # Set up local-mode services (hardware detection + dependency install)
    local has_local=false
    for entry in "${SERVICES[@]}"; do
        local mode
        mode=$(_get_mode "$entry")
        [[ "$mode" == "local" ]] && has_local=true
    done
    [[ "$has_local" != "true" ]] && { echo -e "  ${DIM}No local-mode services to set up${NC}"; return 0; }

    for entry in "${SERVICES[@]}"; do
        local name mode dir
        name=$(_get_name "$entry")
        mode=$(_get_mode "$entry")
        dir="${JARVIS_ROOT}/${name}"

        [[ "$mode" != "local" ]] && continue
        [[ ! -d "$dir" ]] && continue

        # Services with setup.sh have sophisticated setup (hardware detection + run.sh --setup)
        if [[ -f "$dir/setup.sh" ]]; then
            # Run hardware setup wizard if needed (auto-detect, non-interactive)
            if [[ ! -f "$dir/.setup_config" ]]; then
                echo -ne "  ${BLUE}...${NC}   ${name} (detecting hardware)"
                if (cd "$dir" && bash setup.sh --auto >/dev/null 2>&1); then
                    echo -e "\r  ${GREEN}OK${NC}    ${name} hardware configured\033[K"
                else
                    echo -e "\r  ${YELLOW}WARN${NC}  ${name} hardware setup failed (run manually: cd ${name} && bash setup.sh)\033[K"
                fi
            fi

            # Install dependencies via run.sh --setup (venv + deps + acceleration libs)
            if [[ -f "$dir/run.sh" ]]; then
                echo -ne "  ${BLUE}...${NC}   ${name} (installing dependencies — may take a few minutes)"
                local setup_output
                if setup_output=$(cd "$dir" && AUTO_SETUP=true bash run.sh --setup 2>&1); then
                    echo -e "\r  ${GREEN}OK${NC}    ${name} dependencies installed\033[K"
                else
                    echo -e "\r  ${YELLOW}WARN${NC}  ${name} dependency install had issues\033[K"
                    echo "$setup_output" | tail -5 | while IFS= read -r line; do
                        echo -e "        ${DIM}${line}${NC}"
                    done
                    echo -e "        ${DIM}Run manually: cd ${name} && bash run.sh --rebuild${NC}"
                fi
            fi
        else
            # Check if it's a Poetry project (pre-install so start is fast)
            if grep -q 'poetry' "$dir/pyproject.toml" 2>/dev/null && command -v poetry >/dev/null 2>&1; then
                echo -ne "  ${BLUE}...${NC}   ${name} (installing dependencies via Poetry)"
                local poetry_output
                if poetry_output=$(cd "$dir" && poetry install 2>&1); then
                    echo -e "\r  ${GREEN}OK${NC}    ${name} dependencies installed\033[K"
                else
                    echo -e "\r  ${YELLOW}WARN${NC}  ${name} poetry install had issues\033[K"
                    echo "$poetry_output" | tail -3 | while IFS= read -r line; do
                        echo -e "        ${DIM}${line}${NC}"
                    done
                fi
                # Also create .venv for migration scripts (apply_migrations.sh uses .venv/bin/python)
                _ensure_venv "$dir" "$name" 2>/dev/null || true
            else
                # Basic venv setup for simpler local services
                _ensure_venv "$dir" "$name" || echo -e "  ${YELLOW}WARN${NC}  ${name} venv setup failed"
            fi
        fi
    done
}

cmd_init() {
    echo -e "${BOLD}JARVIS INIT${NC}"
    echo ""

    echo -e "${DIM}Step 1: Generate tokens${NC}"
    _generate_tokens

    echo -e "\n${DIM}Step 2: Configure database names${NC}"
    if [[ "$CUSTOM_INIT" == true ]]; then
        _prompt_db_names
    else
        _write_db_defaults
    fi

    echo -e "\n${DIM}Step 3: Stamp .env files${NC}"
    _stamp_env_files

    echo -e "\n${DIM}Step 4: Set up local services${NC}"
    _setup_local_services

    echo ""
    _start_infra

    echo ""
    _create_databases

    echo ""
    _run_migrations

    echo ""
    echo -e "${BOLD}Init complete.${NC}"
    echo -e "  Next: ${CYAN}./jarvis start --all${NC}"
}

# ── LLM Wizard ────────────────────────────────────────────────────────────────

_write_llm_env_fallback() {
    # Write LLM settings to .env file (used when API is unavailable)
    local llm_env="$1" model_value="$2" backend="$3" chat_format="$4"
    local context_window="$5" n_threads="$6" gpu_mem_util="$7" quantization="${8:-}"

    _inject_env_var "$llm_env" "JARVIS_MODEL_NAME" "$model_value"
    _inject_env_var "$llm_env" "JARVIS_MODEL_BACKEND" "$backend"
    _inject_env_var "$llm_env" "JARVIS_CHAT_FORMAT" "$chat_format"
    _inject_env_var "$llm_env" "JARVIS_CONTEXT_WINDOW" "$context_window"

    if [[ "$backend" == "GGUF" && -n "$n_threads" ]]; then
        _inject_env_var "$llm_env" "JARVIS_GGUF_N_THREADS" "$n_threads"
        _inject_env_var "$llm_env" "JARVIS_GGUF_N_GPU_LAYERS" "-1"
    fi
    if [[ "$backend" == "VLLM" ]]; then
        if [[ -n "$gpu_mem_util" ]]; then
            _inject_env_var "$llm_env" "JARVIS_VLLM_GPU_MEMORY_UTILIZATION" "$gpu_mem_util"
        fi
        if [[ -n "$quantization" ]]; then
            _inject_env_var "$llm_env" "JARVIS_VLLM_QUANTIZATION" "$quantization"
        fi
    fi
}

_llm_wizard() {
    echo ""
    echo -e "${BOLD}LLM SETUP WIZARD${NC}"
    echo ""

    local llm_dir="${JARVIS_ROOT}/jarvis-llm-proxy-api"
    local models_dir="${llm_dir}/.models"
    mkdir -p "$models_dir"

    # ── Step 1: Detect OS, backend, and GPU VRAM ─────────────────────────────
    local os_name backend gpu_vram_mb=0
    os_name="$(uname -s)"
    if [[ "$os_name" == "Darwin" ]]; then
        backend="GGUF"
        echo -e "  Detected ${CYAN}macOS${NC} — using ${CYAN}GGUF${NC} backend (llama.cpp + Metal)"
    else
        backend="VLLM"
        if command -v nvidia-smi >/dev/null 2>&1; then
            gpu_vram_mb=$(nvidia-smi --query-gpu=memory.total --format=csv,noheader,nounits 2>/dev/null | head -1)
            gpu_vram_mb="${gpu_vram_mb// /}"
            [[ "$gpu_vram_mb" =~ ^[0-9]+$ ]] || gpu_vram_mb=0
            if (( gpu_vram_mb > 0 )); then
                echo -e "  Detected ${CYAN}Linux + NVIDIA GPU${NC} (${CYAN}$((gpu_vram_mb / 1024))GB VRAM${NC}) — using ${CYAN}vLLM${NC} backend"
            else
                backend="GGUF"
                echo -e "  Detected ${CYAN}Linux (no NVIDIA GPU)${NC} — using ${CYAN}GGUF${NC} backend (llama.cpp)"
            fi
        else
            backend="GGUF"
            echo -e "  Detected ${CYAN}Linux (no NVIDIA GPU)${NC} — using ${CYAN}GGUF${NC} backend (llama.cpp)"
        fi
    fi
    echo ""

    # ── Step 2: Scan already-downloaded models ────────────────────────────────
    local -a local_models=()   # "dir_name|model_type|quant_method|bits|context_window|disk_size"
    local local_model_data
    local_model_data=$(python3 -c "
import json, os, sys, subprocess
models_dir = sys.argv[1]
for d in sorted(os.listdir(models_dir)):
    config = os.path.join(models_dir, d, 'config.json')
    if not os.path.isfile(config):
        continue
    try:
        c = json.load(open(config))
    except Exception:
        continue
    mt = c.get('model_type', 'unknown')
    qc = c.get('quantization_config', {})
    qm = qc.get('quant_method', 'fp16')
    bits = qc.get('bits', 16)
    ctx = c.get('max_position_embeddings', 0)
    # Get disk size
    try:
        out = subprocess.check_output(['du', '-sh', os.path.join(models_dir, d)], stderr=subprocess.DEVNULL, text=True)
        size = out.split()[0]
    except Exception:
        size = '?'
    print(f'{d}|{mt}|{qm}|{bits}|{ctx}|{size}')
" "$models_dir" 2>/dev/null)

    if [[ -n "$local_model_data" ]]; then
        while IFS= read -r line; do
            [[ -n "$line" ]] && local_models+=("$line")
        done <<< "$local_model_data"
    fi

    # ── Step 3: Display model menu ────────────────────────────────────────────
    local idx=0
    local -a menu_entries=()   # "type|index"  type=local or catalog
    local -a menu_labels=()    # display labels for menu items

    # Show local models first
    if (( ${#local_models[@]} > 0 )); then
        echo -e "  ${BOLD}Already downloaded:${NC}"
        echo ""

        for lm in "${local_models[@]}"; do
            local dir_name quant_method bits disk_size model_type
            dir_name=$(_parse_field "$lm" 1)
            model_type=$(_parse_field "$lm" 2)
            quant_method=$(_parse_field "$lm" 3)
            bits=$(_parse_field "$lm" 4)
            disk_size=$(_parse_field "$lm" 6)

            local quant_label="${quant_method}"
            if [[ "$quant_method" != "fp16" ]]; then
                quant_label="${quant_method} ${bits}-bit"
            fi

            idx=$((idx + 1))
            menu_entries+=("local|$((idx - 1))")
            menu_labels+=("$dir_name")

            printf "    ${CYAN}%2d)${NC} %-40s ${DIM}%s, %s${NC}\n" "$idx" "$dir_name" "$quant_label" "$disk_size"
        done
        echo ""
    fi

    # Show downloadable catalog (filtered by VRAM for vLLM)
    echo -e "  ${BOLD}Download new model:${NC}"
    if [[ "$backend" == "VLLM" ]] && (( gpu_vram_mb > 0 )); then
        echo -e "  ${DIM}Showing models that fit in ${gpu_vram_mb}MB VRAM (with headroom)${NC}"
    fi
    echo ""

    local usable_vram_mb=0
    if (( gpu_vram_mb > 0 )); then
        # Reserve ~15% headroom for KV cache and overhead
        usable_vram_mb=$(( gpu_vram_mb * 85 / 100 ))
    fi

    local catalog_count=0
    for model_entry in "${LLM_MODELS[@]}"; do
        local display_name size_display gated_badge vram_required
        display_name=$(_parse_field "$model_entry" 1)
        vram_required=$(_parse_field "$model_entry" 9)
        gated_badge=""
        if [[ "$(_parse_field "$model_entry" 10)" == "yes" ]]; then
            gated_badge=" ${YELLOW}[gated]${NC}"
        fi

        if [[ "$backend" == "GGUF" ]]; then
            size_display=$(_parse_field "$model_entry" 8)
        else
            size_display=$(_parse_field "$model_entry" 7)
        fi

        # Filter by VRAM for vLLM
        if [[ "$backend" == "VLLM" ]] && (( usable_vram_mb > 0 )) && [[ "$vram_required" =~ ^[0-9]+$ ]]; then
            if (( vram_required > usable_vram_mb )); then
                continue
            fi
        fi

        idx=$((idx + 1))
        catalog_count=$((catalog_count + 1))
        menu_entries+=("catalog|$((catalog_count - 1))")
        menu_labels+=("$display_name")

        printf "    ${CYAN}%2d)${NC} %-40s ${DIM}~%s${NC}%b\n" "$idx" "$display_name" "$size_display" "$gated_badge"
    done

    if (( catalog_count == 0 )); then
        echo -e "    ${DIM}(no models fit in detected VRAM — use 'Other' below)${NC}"
    fi

    # "Other" option
    idx=$((idx + 1))
    menu_entries+=("custom|0")
    menu_labels+=("Other")
    printf "    ${CYAN}%2d)${NC} %-40s ${DIM}(enter HuggingFace model ID)${NC}\n" "$idx" "Other"
    echo ""

    # ── Step 4: Prompt for selection ──────────────────────────────────────────
    local selection
    while true; do
        printf "  Select model [1-%d]: " "$idx"
        read -r selection
        if [[ "$selection" =~ ^[0-9]+$ ]] && (( selection >= 1 && selection <= idx )); then
            break
        fi
        echo -e "  ${RED}Invalid selection. Please enter a number 1-${idx}.${NC}"
    done

    local menu_type menu_idx
    menu_type=$(_parse_field "${menu_entries[$((selection - 1))]}" 1)
    menu_idx=$(_parse_field "${menu_entries[$((selection - 1))]}" 2)

    local model_name hf_repo_vllm hf_repo_gguf gguf_filename chat_format context_window is_gated quantization=""
    local skip_download=false

    if [[ "$menu_type" == "local" ]]; then
        # User picked an already-downloaded model
        local lm_entry="${local_models[$menu_idx]}"
        local dir_name model_type quant_method
        dir_name=$(_parse_field "$lm_entry" 1)
        model_type=$(_parse_field "$lm_entry" 2)
        quant_method=$(_parse_field "$lm_entry" 3)
        context_window=$(_parse_field "$lm_entry" 5)

        model_name="$dir_name"
        hf_repo_vllm=""
        hf_repo_gguf=""
        gguf_filename=""
        is_gated="no"
        skip_download=true

        # Map model_type → chat_format
        case "$model_type" in
            llama)   chat_format="llama3" ;;
            qwen2)   chat_format="qwen2" ;;
            qwen3)   chat_format="qwen3" ;;
            mistral) chat_format="mistral" ;;
            gemma|gemma2|gemma3) chat_format="gemma" ;;
            *)       chat_format="chatml" ;;
        esac

        # Detect quantization
        if [[ "$quant_method" == "awq" ]]; then
            quantization="awq"
        elif [[ "$quant_method" == "gptq" || "$quant_method" == "compressed-tensors" ]]; then
            quantization="$quant_method"
        fi

        # Default context if not detected
        if [[ "$context_window" == "0" || -z "$context_window" ]]; then
            context_window="32768"
        fi

    elif [[ "$menu_type" == "catalog" ]]; then
        # Find the actual catalog entry (accounting for VRAM-filtered indices)
        local filtered_idx=0
        local selected_entry=""
        for model_entry in "${LLM_MODELS[@]}"; do
            local vram_required
            vram_required=$(_parse_field "$model_entry" 9)

            # Apply same VRAM filter as display
            if [[ "$backend" == "VLLM" ]] && (( usable_vram_mb > 0 )) && [[ "$vram_required" =~ ^[0-9]+$ ]]; then
                if (( vram_required > usable_vram_mb )); then
                    continue
                fi
            fi

            if (( filtered_idx == menu_idx )); then
                selected_entry="$model_entry"
                break
            fi
            filtered_idx=$((filtered_idx + 1))
        done

        model_name=$(_parse_field "$selected_entry" 1)
        hf_repo_vllm=$(_parse_field "$selected_entry" 2)
        hf_repo_gguf=$(_parse_field "$selected_entry" 3)
        gguf_filename=$(_parse_field "$selected_entry" 4)
        chat_format=$(_parse_field "$selected_entry" 5)
        context_window=$(_parse_field "$selected_entry" 6)
        is_gated=$(_parse_field "$selected_entry" 10)
        quantization=$(_parse_field "$selected_entry" 11)

    elif [[ "$menu_type" == "custom" ]]; then
        printf "  HuggingFace repo (e.g. org/model-name): "
        read -r hf_repo_vllm
        if [[ -z "$hf_repo_vllm" ]]; then
            echo -e "  ${RED}HuggingFace repo is required.${NC}"
            return 1
        fi
        if ! [[ "$hf_repo_vllm" =~ ^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$ ]]; then
            echo -e "  ${RED}Invalid repo format. Expected: org/model-name${NC}"
            return 1
        fi
        hf_repo_gguf="$hf_repo_vllm"
        gguf_filename=""

        if [[ "$backend" == "GGUF" ]]; then
            printf "  GGUF filename (e.g. model-Q4_K_M.gguf): "
            read -r gguf_filename
            if [[ -z "$gguf_filename" ]]; then
                echo -e "  ${RED}GGUF filename is required.${NC}"
                return 1
            fi
            if [[ "$gguf_filename" == */* || "$gguf_filename" == *..* ]] || ! [[ "$gguf_filename" =~ ^[a-zA-Z0-9._-]+$ ]]; then
                echo -e "  ${RED}Invalid filename. Must not contain path separators.${NC}"
                return 1
            fi
            printf "  GGUF repo (if different, or press Enter): "
            read -r custom_gguf_repo
            if [[ -n "$custom_gguf_repo" ]]; then
                if ! [[ "$custom_gguf_repo" =~ ^[a-zA-Z0-9._-]+/[a-zA-Z0-9._-]+$ ]]; then
                    echo -e "  ${RED}Invalid repo format. Expected: org/model-name${NC}"
                    return 1
                fi
                hf_repo_gguf="$custom_gguf_repo"
            fi
        fi

        printf "  Chat format (llama3/qwen3/mistral/gemma/chatml): "
        read -r chat_format
        chat_format="${chat_format:-chatml}"
        case "$chat_format" in
            llama3|qwen2|qwen3|mistral|gemma|chatml) ;;
            *) echo -e "  ${RED}Invalid chat format. Must be: llama3, qwen2, qwen3, mistral, gemma, or chatml${NC}"; return 1 ;;
        esac

        printf "  Context window [32768]: "
        read -r context_window
        context_window="${context_window:-32768}"
        if ! [[ "$context_window" =~ ^[0-9]+$ ]]; then
            echo -e "  ${RED}Context window must be a number. Using default 32768.${NC}"
            context_window="32768"
        fi

        printf "  Quantization (awq/gptq/none) [none]: "
        read -r quantization
        quantization="${quantization:-}"
        case "$quantization" in
            awq|gptq|compressed-tensors|""|none) [[ "$quantization" == "none" ]] && quantization="" ;;
            *) echo -e "  ${RED}Invalid quantization. Must be: awq, gptq, or none${NC}"; return 1 ;;
        esac

        model_name="$hf_repo_vllm"
        is_gated="no"
    fi

    echo ""
    echo -e "  Selected: ${CYAN}${model_name}${NC} (${backend})"

    # ── Step 5: Handle gated models ───────────────────────────────────────────
    if [[ "$is_gated" == "yes" ]]; then
        echo ""
        echo -e "  ${YELLOW}This model requires a HuggingFace access agreement.${NC}"
        echo -e "  ${DIM}Visit the model page on huggingface.co and accept the terms first.${NC}"

        local hf_token=""

        if [[ -n "${HUGGINGFACE_HUB_TOKEN:-}" ]]; then
            hf_token="$HUGGINGFACE_HUB_TOKEN"
            echo -e "  ${GREEN}OK${NC}    Found HuggingFace token in environment"
        elif [[ -f "${HOME}/.cache/huggingface/token" ]]; then
            hf_token=$(cat "${HOME}/.cache/huggingface/token" 2>/dev/null)
            echo -e "  ${GREEN}OK${NC}    Found HuggingFace token in ~/.cache/huggingface/token"
        fi

        if [[ -z "$hf_token" ]]; then
            printf "  Enter HuggingFace token (hf_...): "
            read -rs hf_token
            echo ""
            if [[ -z "$hf_token" ]]; then
                echo -e "  ${RED}No token provided. Cannot download gated model.${NC}"
                return 1
            fi
        fi

        export HUGGINGFACE_HUB_TOKEN="$hf_token"

        _inject_env_var "$TOKEN_FILE" "HUGGINGFACE_HUB_TOKEN" "$hf_token"
        chmod 600 "$TOKEN_FILE"
        echo -e "  ${GREEN}OK${NC}    Saved HuggingFace token to ${TOKEN_FILE}"
    fi

    # ── Step 6: Download model (if needed) ────────────────────────────────────
    local model_value

    if [[ "$skip_download" == true ]]; then
        # Local model — already have it
        model_value=".models/${model_name}"
        echo ""
        echo -e "  ${GREEN}OK${NC}    Using existing model at ${models_dir}/${model_name}"
    else
        # Check if model already exists on disk
        local model_exists=false
        local model_path

        if [[ "$backend" == "GGUF" ]]; then
            model_path="${models_dir}/${gguf_filename}"
            [[ -f "$model_path" ]] && model_exists=true
        else
            local repo_basename="${hf_repo_vllm##*/}"
            model_path="${models_dir}/${repo_basename}"
            [[ -d "$model_path" && -f "${model_path}/config.json" ]] && model_exists=true
        fi

        if [[ "$model_exists" == true ]]; then
            echo ""
            echo -e "  ${GREEN}OK${NC}    Model already downloaded at ${model_path}"
        else
            echo ""
            echo -e "  ${DIM}Downloading model (this may take a while)...${NC}"

            # Find a Python with huggingface_hub installed
            local hf_python=""
            for candidate in "${llm_dir}/.venv/bin/python" "${llm_dir}/venv/bin/python" "python3"; do
                if [[ -x "$candidate" ]] || command -v "$candidate" >/dev/null 2>&1; then
                    if "$candidate" -c "import huggingface_hub" 2>/dev/null; then
                        hf_python="$candidate"
                        break
                    fi
                fi
            done

            if [[ -z "$hf_python" ]]; then
                # Try to install huggingface-hub
                echo -e "  ${DIM}Installing huggingface-hub...${NC}"
                local pip_cmd=""
                if [[ -x "${llm_dir}/.venv/bin/pip" ]]; then
                    pip_cmd="${llm_dir}/.venv/bin/pip"
                elif [[ -x "${llm_dir}/venv/bin/pip" ]]; then
                    pip_cmd="${llm_dir}/venv/bin/pip"
                else
                    pip_cmd="pip3"
                fi

                if "$pip_cmd" install -q huggingface-hub 2>/dev/null; then
                    for candidate in "${llm_dir}/.venv/bin/python" "${llm_dir}/venv/bin/python" "python3"; do
                        if "$candidate" -c "import huggingface_hub" 2>/dev/null; then
                            hf_python="$candidate"
                            break
                        fi
                    done
                fi
            fi

            if [[ -z "$hf_python" ]]; then
                echo -e "  ${RED}FAIL${NC}  Cannot find Python with huggingface_hub installed"
                echo -e "  ${DIM}Install manually: pip install huggingface-hub${NC}"
                return 1
            fi

            if [[ "$backend" == "GGUF" ]]; then
                echo -e "  ${DIM}Downloading: ${hf_repo_gguf} / ${gguf_filename}${NC}"
                if ! "$hf_python" -c "
from huggingface_hub import hf_hub_download
import sys, os
token = os.environ.get('HUGGINGFACE_HUB_TOKEN', '') or None
hf_hub_download(
    repo_id=sys.argv[1],
    filename=sys.argv[2],
    local_dir=sys.argv[3],
    token=token,
)
" "$hf_repo_gguf" "$gguf_filename" "$models_dir"; then
                    echo -e "  ${RED}FAIL${NC}  Download failed"
                    return 1
                fi
            else
                local repo_basename="${hf_repo_vllm##*/}"
                echo -e "  ${DIM}Downloading: ${hf_repo_vllm} → .models/${repo_basename}${NC}"
                if ! "$hf_python" -c "
from huggingface_hub import snapshot_download
import sys, os
token = os.environ.get('HUGGINGFACE_HUB_TOKEN', '') or None
snapshot_download(
    repo_id=sys.argv[1],
    local_dir=sys.argv[2],
    token=token,
)
" "$hf_repo_vllm" "${models_dir}/${repo_basename}"; then
                    echo -e "  ${RED}FAIL${NC}  Download failed"
                    return 1
                fi
            fi

            echo -e "  ${GREEN}OK${NC}    Model downloaded"
        fi

        if [[ "$backend" == "GGUF" ]]; then
            model_value=".models/${gguf_filename}"
        else
            model_value=".models/${hf_repo_vllm##*/}"
        fi
    fi

    # ── Step 7: Detect hardware defaults ──────────────────────────────────────
    local n_threads="" gpu_mem_util=""

    if [[ "$backend" == "GGUF" ]]; then
        if [[ "$os_name" == "Darwin" ]]; then
            n_threads=$(sysctl -n hw.logicalcpu 2>/dev/null || echo "4")
        else
            n_threads=$(nproc 2>/dev/null || echo "4")
        fi
    fi

    if [[ "$backend" == "VLLM" ]] && (( gpu_vram_mb > 0 )); then
        if (( gpu_vram_mb > 16000 )); then
            gpu_mem_util="0.9"
        else
            gpu_mem_util="0.8"
        fi
    fi

    # ── Step 8: Write settings to database via llm-proxy API ──────────────────
    echo ""
    echo -e "  ${DIM}Configuring LLM settings...${NC}"

    local llm_env="${llm_dir}/.env"
    local app_id="" app_key=""

    if [[ -f "$llm_env" ]]; then
        app_id=$(grep "^JARVIS_APP_ID=" "$llm_env" 2>/dev/null | cut -d= -f2-)
        app_key=$(grep "^JARVIS_APP_KEY=" "$llm_env" 2>/dev/null | cut -d= -f2-)
    fi

    if [[ -z "$app_id" || -z "$app_key" ]]; then
        echo -e "  ${YELLOW}WARN${NC}  No JARVIS_APP_ID/JARVIS_APP_KEY in llm-proxy .env"
        echo -e "  ${DIM}Settings will be applied on next service restart via env vars.${NC}"
        _write_llm_env_fallback "$llm_env" "$model_value" "$backend" "$chat_format" \
            "$context_window" "$n_threads" "$gpu_mem_util" "$quantization"
        echo -e "  ${GREEN}OK${NC}    Settings written to ${llm_env}"
    else
        # Build JSON safely using python to avoid injection
        local settings_json
        settings_json=$(python3 -c "
import json, sys
s = {
    'model.main.name': sys.argv[1],
    'model.main.backend': sys.argv[2],
    'model.main.chat_format': sys.argv[3],
    'model.main.context_window': int(sys.argv[4]),
}
backend = sys.argv[2]
n_threads = sys.argv[5]
gpu_mem = sys.argv[6]
quantization = sys.argv[7]
if backend == 'GGUF':
    s['inference.gguf.n_gpu_layers'] = -1
    if n_threads:
        s['inference.gguf.n_threads'] = int(n_threads)
if backend == 'VLLM':
    if gpu_mem:
        s['inference.vllm.gpu_memory_utilization'] = float(gpu_mem)
    if quantization:
        s['inference.vllm.quantization'] = quantization
print(json.dumps({'settings': s}))
" "$model_value" "$backend" "$chat_format" "$context_window" "${n_threads:-}" "${gpu_mem_util:-}" "${quantization:-}" 2>/dev/null)

        if [[ -z "$settings_json" ]]; then
            echo -e "  ${YELLOW}WARN${NC}  Failed to build settings JSON, falling back to .env"
            _write_llm_env_fallback "$llm_env" "$model_value" "$backend" "$chat_format" \
                "$context_window" "$n_threads" "$gpu_mem_util" "$quantization"
            echo -e "  ${GREEN}OK${NC}    Settings written to ${llm_env}"
        else
            local api_response api_code
            api_response=$(curl -s -w "\n%{http_code}" --max-time 10 --connect-timeout 5 -X PUT \
                "http://localhost:7704/settings/" \
                -H "X-Jarvis-App-Id: ${app_id}" \
                -H "X-Jarvis-App-Key: ${app_key}" \
                -H "Content-Type: application/json" \
                -d "$settings_json" 2>/dev/null)

            api_code=$(echo "$api_response" | tail -1)

            if [[ "$api_code" == "200" ]]; then
                echo -e "  ${GREEN}OK${NC}    Settings written to database via API"
            else
                echo -e "  ${YELLOW}WARN${NC}  API returned HTTP ${api_code}, falling back to .env"
                _write_llm_env_fallback "$llm_env" "$model_value" "$backend" "$chat_format" \
                    "$context_window" "$n_threads" "$gpu_mem_util" "$quantization"
                echo -e "  ${GREEN}OK${NC}    Settings written to ${llm_env}"
            fi
        fi
    fi

    # ── Step 9: Restart llm-proxy ─────────────────────────────────────────────
    echo ""
    echo -e "  ${DIM}Restarting LLM proxy service...${NC}"

    local llm_entry
    llm_entry=$(_find_service "jarvis-llm-proxy-api") || {
        echo -e "  ${YELLOW}WARN${NC}  jarvis-llm-proxy-api not found in service registry"
        return 0
    }

    _restart_one "$llm_entry" "$STANDALONE"

    echo -ne "  ${BLUE}...${NC}   Waiting for LLM proxy to load model (up to 120s)"
    if _wait_for_health "jarvis-llm-proxy-api" 7704 "/health" 120; then
        echo -e "\r  ${GREEN}OK${NC}    LLM proxy healthy                                   "
    else
        echo -e "\r  ${YELLOW}WARN${NC}  LLM proxy health check timed out (model may still be loading)"
        echo -e "  ${DIM}Check status: curl http://localhost:7704/health${NC}"
    fi

    # Summary
    echo ""
    echo -e "  ${GREEN}LLM configured:${NC} ${CYAN}${model_name}${NC} on ${CYAN}${backend}${NC}"
    if [[ -n "$quantization" ]]; then
        echo -e "  ${DIM}Quantization: ${quantization}${NC}"
    fi
    if [[ "$backend" == "GGUF" ]]; then
        echo -e "  ${DIM}Threads: ${n_threads}, GPU layers: all${NC}"
    elif [[ -n "$gpu_mem_util" ]]; then
        echo -e "  ${DIM}GPU memory utilization: ${gpu_mem_util}${NC}"
    fi
}

cmd_quickstart() {
    echo -e "${BOLD}JARVIS QUICKSTART${NC}"
    echo -e "${DIM}Full setup: init + start + LLM wizard${NC}"
    echo ""

    # Step 1-7: Run init (tokens, DBs, env files, infra, migrations)
    echo -e "${BOLD}Phase 1: Initialize${NC}"
    cmd_init

    # Step 8: Start all services
    echo ""
    echo -e "${BOLD}Phase 2: Start Services${NC}"
    cmd_start "--all" "" "$STANDALONE"

    # Step 9: LLM Setup Wizard
    echo ""
    echo -e "${BOLD}Phase 3: LLM Setup${NC}"

    # Check if llm-proxy is running before starting wizard
    if ! _wait_for_health "jarvis-llm-proxy-api" 7704 "/health" 30; then
        echo -e "  ${YELLOW}WARN${NC}  jarvis-llm-proxy-api not responding, skipping LLM wizard"
        echo -e "  ${DIM}Run the wizard later: ./jarvis llm-setup${NC}"
    else
        _llm_wizard
    fi

    echo ""
    echo -e "${BOLD}Quickstart complete.${NC}"
    echo -e "  Dashboard: ${CYAN}http://localhost:7710${NC}"
    echo -e "  LLM API:   ${CYAN}http://localhost:7704/health${NC}"
}

# ── Start ────────────────────────────────────────────────────────────────────

_ensure_venv() {
    # Ensure .venv exists and deps are installed for a local-mode service
    local dir="$1" name="$2"
    local venv_dir="${dir}/.venv"

    if [[ -x "${venv_dir}/bin/python" ]]; then
        return 0
    fi

    # Also accept legacy venv/ directory
    if [[ -x "${dir}/venv/bin/python" ]]; then
        return 0
    fi

    echo ""
    echo -ne "        ${DIM}creating .venv for ${name}...${NC}"
    if ! python3 -m venv "$venv_dir" 2>/dev/null; then
        echo -e "\r        ${RED}failed to create .venv${NC}     "
        return 1
    fi

    echo -e "\r        ${DIM}installing deps for ${name}...${NC}  "
    local pip_output

    # Prefer requirements.txt (works with pip directly); fall back to pyproject.toml
    if [[ -f "${dir}/requirements.txt" ]]; then
        if ! pip_output=$("${venv_dir}/bin/pip" install -q -r "${dir}/requirements.txt" 2>&1); then
            echo -e "        ${RED}pip install failed:${NC}"
            echo "$pip_output" | tail -5 | while IFS= read -r line; do
                echo -e "        ${DIM}${line}${NC}"
            done
            return 1
        fi
    elif [[ -f "${dir}/pyproject.toml" ]]; then
        if ! pip_output=$("${venv_dir}/bin/pip" install -q -e "$dir" 2>&1); then
            echo -e "        ${RED}pip install failed:${NC}"
            echo "$pip_output" | tail -5 | while IFS= read -r line; do
                echo -e "        ${DIM}${line}${NC}"
            done
            return 1
        fi
    fi

    echo -e "        ${GREEN}OK${NC}    .venv ready"
    return 0
}

_start_one() {
    local entry="$1" build_flag="${2:-}" standalone="${3:-false}"
    local name port tier mode
    name=$(_get_name "$entry")
    port=$(_get_port "$entry")
    tier=$(_get_tier "$entry")
    mode=$(_get_mode "$entry")

    local dir="${JARVIS_ROOT}/${name}"
    if [[ ! -d "$dir" ]]; then
        echo -e "  ${YELLOW}SKIP${NC}  ${name} (directory not found)"
        return 0
    fi

    # Check if already running
    if curl -sf --max-time 2 "http://localhost:${port}$(_get_health "$entry")" >/dev/null 2>&1; then
        echo -e "  ${GREEN}UP${NC}    ${name} :${port}"
        return 0
    fi

    echo -ne "  ${BLUE}...${NC}   ${name} :${port}"

    case "$mode" in
        docker)
            local compose_file=""
            compose_file=$(_find_compose_file "$dir")

            if [[ -z "$compose_file" ]]; then
                echo -e "\r  ${RED}FAIL${NC}  ${name} (no docker-compose file found)"
                return 1
            fi

            local env_flag=""
            [[ -f "$dir/.env" ]] && env_flag="--env-file .env"

            local compose_flags=""
            if [[ "$standalone" == true ]]; then
                # Standalone: use profile, no network overlay
                compose_flags="--profile standalone -f $compose_file"
            else
                compose_flags=$(_get_compose_flags "$dir") || {
                    echo -e "\r  ${RED}FAIL${NC}  ${name} (no docker-compose file found)"
                    return 1
                }
            fi

            local compose_output
            if ! compose_output=$(cd "$dir" && docker compose $env_flag $compose_flags up -d $build_flag 2>&1); then
                echo -e "\r  ${RED}FAIL${NC}  ${name} (docker compose up failed)"
                echo -e "  ${DIM}${compose_output}${NC}"
                return 1
            fi
            ;;
        local)
            if [[ -f "$dir/run.sh" ]]; then
                # run.sh handles its own venv creation + deps (set up during init)
                (cd "$dir" && AUTO_SETUP=true exec bash run.sh >> "${LOG_DIR}/${name}.log" 2>&1) &
                echo $! > "${PID_DIR}/${name}.pid"
            else
                echo -e "\r  ${RED}FAIL${NC}  ${name} (no run.sh found)"
                return 1
            fi
            ;;
        npm)
            if [[ -f "$dir/package.json" ]]; then
                # Source nvm for correct Node.js version
                local nvm_init="${HOME}/.nvm/nvm.sh"
                local nvm_cmd=""
                if [[ -f "$nvm_init" ]]; then
                    nvm_cmd="source $nvm_init && nvm use default --silent &&"
                fi

                # Load .env from service root so backend gets env vars like AUTH_URL
                local env_export=""
                if [[ -f "$dir/.env" ]]; then
                    env_export="set -a && source $dir/.env && set +a &&"
                fi

                # Start backend server if it exists (e.g. jarvis-admin/server)
                if [[ -f "$dir/server/package.json" ]]; then
                    (cd "$dir/server" && eval "$env_export $nvm_cmd exec npm run dev" >> "${LOG_DIR}/${name}-server.log" 2>&1) &
                    echo $! > "${PID_DIR}/${name}-server.pid"
                fi

                # Start frontend dev server
                (cd "$dir" && eval "$nvm_cmd exec npm run dev" >> "${LOG_DIR}/${name}.log" 2>&1) &
                echo $! > "${PID_DIR}/${name}.pid"
            else
                echo -e "\r  ${RED}FAIL${NC}  ${name} (no package.json found)"
                return 1
            fi
            ;;
    esac

    echo -e "\r  ${GREEN}START${NC} ${name} :${port}"
}

_start_tier() {
    local target_tier="$1" build_flag="${2:-}"
    for entry in "${SERVICES[@]}"; do
        local tier
        tier=$(_get_tier "$entry")
        if [[ "$tier" == "$target_tier" ]]; then
            _start_one "$entry" "$build_flag"
        fi
    done
}

_restart_one() {
    local entry="$1" standalone="${2:-false}"
    local name mode dir
    name=$(_get_name "$entry")
    mode=$(_get_mode "$entry")
    dir="${JARVIS_ROOT}/${name}"

    case "$mode" in
        docker)
            local env_flag=""
            [[ -f "$dir/.env" ]] && env_flag="--env-file .env"

            local compose_flags=""
            if [[ "$standalone" == true ]]; then
                local compose_file
                compose_file=$(_find_compose_file "$dir")
                compose_flags="--profile standalone -f $compose_file"
            else
                compose_flags=$(_get_compose_flags "$dir") || return 1
            fi
            # Use stop+up (not restart) so Docker picks up .env file changes
            (cd "$dir" && docker compose $env_flag $compose_flags stop 2>/dev/null) || true
            local restart_output
            if ! restart_output=$(cd "$dir" && docker compose $env_flag $compose_flags up -d 2>&1); then
                echo -e "\r  ${YELLOW}WARN${NC}  restart failed for ${name}: $(echo "$restart_output" | tail -1)"
            fi
            ;;
        local|npm)
            _stop_one "$entry" "$standalone" >/dev/null 2>&1
            sleep 1
            _start_one "$entry" "" "$standalone" >/dev/null 2>&1
            ;;
    esac
}

_auto_register() {
    # Auto-register healthy services with config-service + jarvis-auth.
    # Args: list of healthy service names to register.
    # Sets global RESTART_SERVICES=() with names that got new .env credentials.
    local -a healthy=("$@")

    if [[ ${#healthy[@]} -eq 0 ]]; then
        echo -e "  ${YELLOW}SKIP${NC}  Auto-registration (no healthy services)"
        return 0
    fi

    local token_file="${JARVIS_ROOT}/jarvis-config-service/.env"
    local token=""
    if [[ -f "$token_file" ]]; then
        token=$(grep "^JARVIS_AUTH_ADMIN_TOKEN=" "$token_file" 2>/dev/null | cut -d= -f2-)
    fi
    if [[ -z "$token" ]]; then
        echo -e "  ${YELLOW}SKIP${NC}  Auto-registration (no JARVIS_AUTH_ADMIN_TOKEN)"
        return 0
    fi

    # Wait for config-service and auth to be ready
    if ! _wait_for_health "jarvis-config-service" 7700 "/health" 10; then
        echo -e "  ${YELLOW}SKIP${NC}  Auto-registration (config-service not ready)"
        return 0
    fi
    if ! _wait_for_health "jarvis-auth" 7701 "/health" 10; then
        echo -e "  ${YELLOW}SKIP${NC}  Auto-registration (jarvis-auth not ready)"
        return 0
    fi

    # Build JSON from healthy services only
    local services_json="["
    local first=true
    for name in "${healthy[@]}"; do
        # Skip admin (no backend registration needed)
        [[ "$name" == "jarvis-admin" ]] && continue

        local port=""
        for entry in "${SERVICES[@]}"; do
            if [[ "$(_get_name "$entry")" == "$name" ]]; then
                port=$(_get_port "$entry")
                break
            fi
        done
        [[ -z "$port" ]] && continue

        [[ "$first" == true ]] && first=false || services_json+=","
        services_json+="{\"name\":\"${name}\",\"host\":\"localhost\",\"port\":${port}}"
    done
    services_json+="]"

    # No base_path — config-service uses JARVIS_ROOT volume mount
    local response body http_code
    response=$(curl -s -w "\n%{http_code}" -X POST \
        "http://localhost:7700/v1/services/register" \
        -H "X-Jarvis-Admin-Token: ${token}" \
        -H "Content-Type: application/json" \
        -d "{\"services\":${services_json}}" 2>/dev/null)

    http_code=$(echo "$response" | tail -1)
    body=$(echo "$response" | sed '$d')

    if [[ "$http_code" != "200" ]]; then
        echo -e "  ${YELLOW}WARN${NC}  Auto-registration returned HTTP ${http_code}"
        return 0
    fi

    # Parse results: extract app_key for new auth clients, track existing ones
    local total=0 new_auth=0 env_written=0
    RESTART_SERVICES=()
    local -a need_key=()  # services with existing auth but no key in .env

    local parse_output
    parse_output=$(echo "$body" | python3 -c "
import json, sys
data = json.load(sys.stdin)
for r in data.get('results', []):
    name = r['name']
    created = r.get('auth_created')
    auth_ok = r.get('auth_ok')
    key = r.get('app_key') or ''
    print(f'{name}|{created}|{auth_ok}|{key}')
" 2>&1) || {
        echo -e "  ${YELLOW}WARN${NC}  Failed to parse registration response"
        return 0
    }

    while IFS= read -r line; do
        [[ -z "$line" ]] && continue
        local svc_name="${line%%|*}"
        local rest="${line#*|}"
        local created="${rest%%|*}"
        rest="${rest#*|}"
        local auth_ok="${rest%%|*}"
        local app_key="${rest#*|}"

        total=$((total + 1))

        local svc_env="${JARVIS_ROOT}/${svc_name}/.env"
        [[ ! -d "${JARVIS_ROOT}/${svc_name}" ]] && continue

        if [[ "$created" == "True" && -n "$app_key" ]]; then
            # New auth client — write credentials
            new_auth=$((new_auth + 1))
            _inject_env_var "$svc_env" "JARVIS_APP_ID" "$svc_name"
            _inject_env_var "$svc_env" "JARVIS_APP_KEY" "$app_key"
            env_written=$((env_written + 1))
            RESTART_SERVICES+=("$svc_name")
        elif [[ "$auth_ok" == "True" ]]; then
            # Existing auth client — check if .env is missing the key
            _inject_env_var "$svc_env" "JARVIS_APP_ID" "$svc_name"
            if ! grep -q "^JARVIS_APP_KEY=.\+" "$svc_env" 2>/dev/null || \
               grep -q "^JARVIS_APP_KEY=your-.*-here$" "$svc_env" 2>/dev/null; then
                need_key+=("$svc_name")
            fi
        fi
    done <<< "$parse_output"

    # Rotate keys for services that have auth clients but missing JARVIS_APP_KEY in .env
    for svc_name in "${need_key[@]}"; do
        local rotate_resp rotate_body rotate_code
        rotate_resp=$(curl -s -w "\n%{http_code}" -X POST \
            "http://localhost:7700/v1/services/rotate-key" \
            -H "X-Jarvis-Admin-Token: ${token}" \
            -H "Content-Type: application/json" \
            -d "{\"service_name\":\"${svc_name}\"}" 2>/dev/null)

        rotate_code=$(echo "$rotate_resp" | tail -1)
        rotate_body=$(echo "$rotate_resp" | sed '$d')

        if [[ "$rotate_code" == "200" ]]; then
            local rotated_key
            rotated_key=$(echo "$rotate_body" | python3 -c "import json,sys; print(json.load(sys.stdin).get('app_key',''))" 2>/dev/null)
            if [[ -n "$rotated_key" ]]; then
                local svc_env="${JARVIS_ROOT}/${svc_name}/.env"
                _inject_env_var "$svc_env" "JARVIS_APP_KEY" "$rotated_key"
                env_written=$((env_written + 1))
                RESTART_SERVICES+=("$svc_name")
            fi
        else
            echo -e "  ${YELLOW}WARN${NC}  Key rotate failed for ${svc_name} (HTTP ${rotate_code})"
        fi
    done

    if [[ $env_written -gt 0 ]]; then
        echo -e "  ${GREEN}OK${NC}    Registered ${total} services (${new_auth} new, ${env_written} .env files updated)"
    else
        echo -e "  ${GREEN}OK${NC}    Registered ${total} services (all credentials up to date)"
    fi
}

cmd_start() {
    local target="$1" build_flag="${2:-}" standalone="${3:-false}"

    echo -e "${BOLD}JARVIS START${NC}"
    echo ""

    if [[ "$target" == "--all" ]]; then
        # Ensure infra is running (unless distributed mode)
        if [[ "$NETWORK_MODE" == "bridge" ]]; then
            _write_network_override

            # Start infra if not already running
            if ! docker exec jarvis-postgres pg_isready -U postgres >/dev/null 2>&1; then
                echo -e "${DIM}Starting infrastructure...${NC}"
                if [[ -d "$DATA_SERVICES_DIR" ]]; then
                    (cd "$DATA_SERVICES_DIR" && docker compose --env-file .env up -d 2>&1) | sed 's/^/  /' || true
                fi

                local elapsed=0
                while (( elapsed < 30 )); do
                    if docker exec jarvis-postgres pg_isready -U postgres >/dev/null 2>&1; then
                        echo -e "  ${GREEN}OK${NC}    Infrastructure ready"
                        break
                    fi
                    sleep 1
                    elapsed=$((elapsed + 1))
                done
                echo ""
            fi
        fi

        # Build images first when --build is set (separate from start)
        if [[ -n "$build_flag" ]]; then
            echo -e "${DIM}Building images...${NC}"
            local build_failed=false
            for entry in "${SERVICES[@]}"; do
                local bmode bname bdir
                bmode=$(_get_mode "$entry")
                [[ "$bmode" != "docker" ]] && continue
                bname=$(_get_name "$entry")
                bdir="${JARVIS_ROOT}/${bname}"
                [[ ! -d "$bdir" ]] && continue

                local bcompose_file benv_flag bcompose_flags
                bcompose_file=$(_find_compose_file "$bdir")
                [[ -z "$bcompose_file" ]] && continue
                benv_flag=""
                [[ -f "$bdir/.env" ]] && benv_flag="--env-file .env"
                if [[ "$standalone" == true ]]; then
                    bcompose_flags="--profile standalone -f $bcompose_file"
                else
                    bcompose_flags=$(_get_compose_flags "$bdir") || continue
                fi

                echo -ne "  ${BLUE}...${NC}   ${bname}"
                local build_output
                if ! build_output=$(cd "$bdir" && docker compose $benv_flag $bcompose_flags build 2>&1); then
                    echo -e "\r  ${RED}FAIL${NC}  ${bname}"
                    echo "$build_output" | tail -5 | while IFS= read -r line; do
                        echo -e "        ${DIM}${line}${NC}"
                    done
                    build_failed=true
                else
                    echo -e "\r  ${GREEN}OK${NC}    ${bname}"
                fi
            done
            echo ""

            if [[ "$build_failed" == true ]]; then
                echo -e "${YELLOW}Some images failed to build. Starting available services...${NC}"
                echo ""
            fi

            # Clear build_flag so _start_one uses plain 'up -d'
            build_flag=""
        fi

        # Get unique tiers in order
        local tiers
        tiers=$(for entry in "${SERVICES[@]}"; do _get_tier "$entry"; done | sort -un)

        local -a HEALTHY_SERVICES=()

        for tier in $tiers; do
            echo -e "${DIM}Tier ${tier}${NC}"
            _start_tier "$tier" "$build_flag"

            # Wait for health of tier before moving to next
            for entry in "${SERVICES[@]}"; do
                local t
                t=$(_get_tier "$entry")
                if [[ "$t" == "$tier" ]]; then
                    local name port health_path dir
                    name=$(_get_name "$entry")
                    port=$(_get_port "$entry")
                    health_path=$(_get_health "$entry")
                    dir="${JARVIS_ROOT}/${name}"
                    [[ ! -d "$dir" ]] && continue
                    if _wait_for_health "$name" "$port" "$health_path" 60; then
                        HEALTHY_SERVICES+=("$name")
                    else
                        echo -e "  ${YELLOW}WAIT${NC}  ${name} (health check timeout)"
                    fi
                fi
            done

            echo ""
        done

        # Auto-register healthy services (config DB + auth app-clients + .env)
        echo -e "${DIM}Registration${NC}"
        RESTART_SERVICES=()
        _auto_register "${HEALTHY_SERVICES[@]}"

        # Restart services that got new .env credentials
        if [[ ${#RESTART_SERVICES[@]} -gt 0 ]]; then
            echo ""
            echo -e "${DIM}Restarting services with new credentials${NC}"
            for svc_name in "${RESTART_SERVICES[@]}"; do
                # Config-service doesn't use app-to-app credentials — no restart needed
                [[ "$svc_name" == "jarvis-config-service" ]] && continue
                local entry
                entry=$(_find_service "$svc_name") || continue
                echo -ne "  ${BLUE}...${NC}   ${svc_name}"
                _restart_one "$entry" "$STANDALONE"
                local port health_path
                port=$(_get_port "$entry")
                health_path=$(_get_health "$entry")
                if _wait_for_health "$svc_name" "$port" "$health_path" 60; then
                    echo -e "\r  ${GREEN}OK${NC}    ${svc_name}"
                else
                    echo -e "\r  ${YELLOW}WARN${NC}  ${svc_name} (health check timeout after restart)"
                fi
            done
        fi
    else
        local entry
        entry=$(_find_service "$target") || {
            echo -e "${RED}Unknown service: ${target}${NC}"
            echo "Available: $(for e in "${SERVICES[@]}"; do _get_name "$e"; done | tr '\n' ' ')"
            exit 1
        }
        _start_one "$entry" "$build_flag" "$standalone"
    fi
}

# ── Stop ─────────────────────────────────────────────────────────────────────

_stop_one() {
    local entry="$1" standalone="${2:-false}"
    local name port mode
    name=$(_get_name "$entry")
    port=$(_get_port "$entry")
    mode=$(_get_mode "$entry")

    local dir="${JARVIS_ROOT}/${name}"
    if [[ ! -d "$dir" ]]; then
        return 0
    fi

    case "$mode" in
        docker)
            local compose_file=""
            compose_file=$(_find_compose_file "$dir")

            if [[ -n "$compose_file" ]]; then
                local env_flag=""
                [[ -f "$dir/.env" ]] && env_flag="--env-file .env"

                local compose_flags=""
                if [[ "$standalone" == true ]]; then
                    compose_flags="--profile standalone -f $compose_file"
                else
                    compose_flags=$(_get_compose_flags "$dir") || compose_flags="-f $compose_file"
                fi

                (cd "$dir" && docker compose $env_flag $compose_flags down >/dev/null 2>&1) || true
            fi
            ;;
        local|npm)
            # Kill process tree from PID files
            for pid_file in "${PID_DIR}/${name}-server.pid" "${PID_DIR}/${name}.pid"; do
                if [[ -f "$pid_file" ]]; then
                    local pid
                    pid=$(cat "$pid_file")
                    _kill_tree "$pid"
                    rm -f "$pid_file"
                fi
            done

            # Fallback: kill anything still listening on the service port
            local remaining
            remaining=$(lsof -ti:"$port" 2>/dev/null || true)
            if [[ -n "$remaining" ]]; then
                echo "$remaining" | xargs kill 2>/dev/null || true
            fi
            ;;
    esac

    echo -e "  ${RED}STOP${NC}  ${name}"
}

cmd_stop() {
    local target="$1" standalone="${2:-false}"

    echo -e "${BOLD}JARVIS STOP${NC}"
    echo ""

    if [[ "$target" == "--all" ]]; then
        # Stop in reverse tier order
        local tiers
        tiers=$(for entry in "${SERVICES[@]}"; do _get_tier "$entry"; done | sort -unr)
        for tier in $tiers; do
            for entry in "${SERVICES[@]}"; do
                local t
                t=$(_get_tier "$entry")
                if [[ "$t" == "$tier" ]]; then
                    _stop_one "$entry" "$standalone"
                fi
            done
        done

        # Stop infrastructure (only in bridge mode, not standalone)
        if [[ "$NETWORK_MODE" == "bridge" ]] && [[ "$standalone" != true ]]; then
            echo ""
            echo -e "${DIM}Stopping infrastructure...${NC}"
            if [[ -d "$DATA_SERVICES_DIR" ]]; then
                (cd "$DATA_SERVICES_DIR" && docker compose --env-file .env down >/dev/null 2>&1) || true
            fi
            echo -e "  ${RED}STOP${NC}  PostgreSQL + Redis + pgAdmin + MinIO"
        fi
    else
        local entry
        entry=$(_find_service "$target") || {
            echo -e "${RED}Unknown service: ${target}${NC}"
            exit 1
        }
        _stop_one "$entry" "$standalone"
    fi
}

# ── Status ───────────────────────────────────────────────────────────────────

cmd_status() {
    echo ""
    echo -e "${BOLD}JARVIS SERVICE STATUS${NC}"
    printf '%.0s\u2550' {1..55}
    echo ""
    printf "%-28s %-6s %-5s %s\n" "SERVICE" "PORT" "TIER" "STATUS"
    printf '%.0s\u2500' {1..55}
    echo ""

    for entry in $(_services_by_tier "asc"); do
        local name port tier health_path
        name=$(_get_name "$entry")
        port=$(_get_port "$entry")
        tier=$(_get_tier "$entry")
        health_path=$(_get_health "$entry")

        local status_str
        if curl -sf --max-time 2 "http://localhost:${port}${health_path}" >/dev/null 2>&1; then
            status_str="${GREEN}UP${NC}"
        else
            status_str="${RED}DOWN${NC}"
        fi

        printf "%-28s %-6s %-5s " "$name" "$port" "$tier"
        echo -e "$status_str"
    done

    echo ""
}

# ── Health ───────────────────────────────────────────────────────────────────

cmd_health() {
    echo ""
    echo -e "${BOLD}JARVIS HEALTH CHECK${NC}"
    printf '%.0s\u2550' {1..65}
    echo ""

    for entry in $(_services_by_tier "asc"); do
        local name port health_path
        name=$(_get_name "$entry")
        port=$(_get_port "$entry")
        health_path=$(_get_health "$entry")

        local url="http://localhost:${port}${health_path}"
        local response
        response=$(curl -sf --max-time 3 "$url" 2>/dev/null) && {
            echo -e "${GREEN}OK${NC}    ${name}  ${DIM}${response}${NC}"
        } || {
            echo -e "${RED}FAIL${NC}  ${name}  ${DIM}${url}${NC}"
        }
    done

    echo ""
}

# ── Logs ─────────────────────────────────────────────────────────────────────

cmd_logs() {
    local target="$1"

    local entry
    entry=$(_find_service "$target") || {
        echo -e "${RED}Unknown service: ${target}${NC}"
        exit 1
    }

    local name dir mode
    name=$(_get_name "$entry")
    dir="${JARVIS_ROOT}/${name}"
    mode=$(_get_mode "$entry")

    if [[ "$mode" == "docker" ]]; then
        local compose_file=""
        compose_file=$(_find_compose_file "$dir")

        if [[ -n "$compose_file" ]]; then
            local env_flag=""
            [[ -f "$dir/.env" ]] && env_flag="--env-file .env"
            (cd "$dir" && docker compose $env_flag -f "$compose_file" logs -f --tail 100)
        else
            echo -e "${RED}No docker-compose file found for ${name}${NC}"
            exit 1
        fi
    else
        local log_file="${LOG_DIR}/${name}.log"
        local server_log="${LOG_DIR}/${name}-server.log"
        if [[ -f "$server_log" ]]; then
            tail -f "$server_log"
        elif [[ -f "$log_file" ]]; then
            tail -f "$log_file"
        else
            echo -e "${YELLOW}${name} has no log file yet — start it first with: ./jarvis start ${name}${NC}"
        fi
    fi
}

# ── Doctor ───────────────────────────────────────────────────────────────────

_check_cmd() {
    local name="$1" cmd="$2"
    local version
    if version=$(eval "$cmd" 2>/dev/null | head -1); then
        echo -e " ${GREEN}\u2713${NC}  ${name} ${DIM}${version}${NC}"
        return 0
    else
        echo -e " ${RED}\u2717${NC}  ${name} — not found"
        return 1
    fi
}

cmd_doctor() {
    echo ""
    echo -e "${BOLD}JARVIS SYSTEM CHECK${NC}"
    printf '%.0s\u2550' {1..55}
    echo ""

    # ── Prerequisites ──
    echo -e "${DIM}Prerequisites:${NC}"
    _check_cmd "Docker" "docker --version" || true
    _check_cmd "Node.js" "node --version" || true
    _check_cmd "Python" "python3 --version" || true
    _check_cmd "OpenSSL" "openssl version" || true
    echo ""

    # ── Infrastructure ──
    echo -e "${DIM}Infrastructure:${NC}"
    if docker exec jarvis-postgres pg_isready -U postgres >/dev/null 2>&1; then
        echo -e " ${GREEN}\u2713${NC}  PostgreSQL reachable (jarvis-postgres)"
    else
        echo -e " ${RED}\u2717${NC}  PostgreSQL not reachable (run: ./jarvis init)"
    fi

    local redis_pw
    redis_pw=$(_get_redis_password)
    if docker exec jarvis-redis redis-cli -a "$redis_pw" ping >/dev/null 2>&1; then
        echo -e " ${GREEN}\u2713${NC}  Redis reachable (jarvis-redis)"
    else
        echo -e " ${RED}\u2717${NC}  Redis not reachable (run: ./jarvis init)"
    fi

    # pgAdmin check (nice-to-have)
    if curl -sf --max-time 2 "http://localhost:5050" >/dev/null 2>&1; then
        echo -e " ${GREEN}\u2713${NC}  pgAdmin reachable (:5050)"
    else
        echo -e " ${DIM}\u2717${NC}  pgAdmin not reachable (:5050)"
    fi

    # MinIO check (nice-to-have)
    if curl -sf --max-time 2 "http://localhost:9000/minio/health/live" >/dev/null 2>&1; then
        echo -e " ${GREEN}\u2713${NC}  MinIO reachable (:9000)"
    else
        echo -e " ${DIM}\u2717${NC}  MinIO not reachable (:9000)"
    fi
    echo ""

    # ── Configuration ──
    echo -e "${DIM}Configuration:${NC}"
    local env_present=0
    local env_missing=0
    local missing_list=""

    for entry in "${SERVICES[@]}"; do
        local name
        name=$(_get_name "$entry")
        local dir="${JARVIS_ROOT}/${name}"
        [[ ! -d "$dir" ]] && continue

        if [[ -f "${dir}/.env" ]]; then
            env_present=$((env_present + 1))
        else
            env_missing=$((env_missing + 1))
            missing_list="${missing_list} ${name}"
        fi
    done

    local total=$(( env_present + env_missing ))
    if [[ $env_missing -eq 0 ]]; then
        echo -e " ${GREEN}\u2713${NC}  .env files present (${env_present}/${total})"
    else
        echo -e " ${YELLOW}\u2717${NC}  .env files: ${env_present}/${total} present"
        for m in $missing_list; do
            echo -e "     ${RED}missing:${NC} ${m}/.env"
        done
    fi

    # Database names config check
    if [[ -f "$DB_FILE" ]]; then
        echo -e " ${GREEN}\u2713${NC}  Database names configured (${DB_FILE})"
    else
        echo -e " ${YELLOW}\u2717${NC}  No database names file (run: ./jarvis init)"
    fi

    # Token consistency checks
    if [[ -f "$TOKEN_FILE" ]]; then
        echo -e " ${GREEN}\u2713${NC}  Master tokens file exists (${TOKEN_FILE})"

        # Check JARVIS_AUTH_ADMIN_TOKEN consistency
        # shellcheck disable=SC1090
        source "$TOKEN_FILE"
        local token_mismatches=0

        for entry in "${SERVICES[@]}"; do
            local name
            name=$(_get_name "$entry")
            local env_file="${JARVIS_ROOT}/${name}/.env"
            [[ ! -f "$env_file" ]] && continue

            local env_token
            env_token=$(grep "^JARVIS_AUTH_ADMIN_TOKEN=" "$env_file" 2>/dev/null | cut -d= -f2-)
            if [[ -n "$env_token" ]] && [[ "$env_token" != "$JARVIS_AUTH_ADMIN_TOKEN" ]]; then
                echo -e "     ${RED}mismatch:${NC} ${name} JARVIS_AUTH_ADMIN_TOKEN differs from master"
                token_mismatches=$((token_mismatches + 1))
            fi
        done

        if [[ $token_mismatches -eq 0 ]]; then
            echo -e " ${GREEN}\u2713${NC}  JARVIS_AUTH_ADMIN_TOKEN consistent across services"
        fi

        # Check JWT secret consistency (auth <-> settings-server)
        local auth_secret="" settings_secret=""
        [[ -f "${JARVIS_ROOT}/jarvis-auth/.env" ]] && \
            auth_secret=$(grep "^AUTH_SECRET_KEY=" "${JARVIS_ROOT}/jarvis-auth/.env" 2>/dev/null | cut -d= -f2-)
        [[ -f "${JARVIS_ROOT}/jarvis-settings-server/.env" ]] && \
            settings_secret=$(grep "^JARVIS_AUTH_SECRET_KEY=" "${JARVIS_ROOT}/jarvis-settings-server/.env" 2>/dev/null | cut -d= -f2-)

        if [[ -n "$auth_secret" ]] && [[ -n "$settings_secret" ]]; then
            if [[ "$auth_secret" == "$settings_secret" ]]; then
                echo -e " ${GREEN}\u2713${NC}  JWT secret consistent (jarvis-auth \u2194 jarvis-settings-server)"
            else
                echo -e " ${RED}\u2717${NC}  JWT secret MISMATCH (jarvis-auth AUTH_SECRET_KEY \u2260 jarvis-settings-server JARVIS_AUTH_SECRET_KEY)"
            fi
        fi
    else
        echo -e " ${YELLOW}\u2717${NC}  No master tokens file (run: ./jarvis init)"
    fi
    echo ""

    # ── Port conflicts ──
    echo -e "${DIM}Ports:${NC}"
    local port_conflicts=0
    for entry in "${SERVICES[@]}"; do
        local name port
        name=$(_get_name "$entry")
        port=$(_get_port "$entry")

        local pid_info
        pid_info=$(ss -tlnp 2>/dev/null | grep ":${port} " | head -1)

        if [[ -n "$pid_info" ]]; then
            # Port is in use — check if it's the expected service (not a conflict)
            if curl -sf --max-time 2 "http://localhost:${port}$(_get_health "$entry")" >/dev/null 2>&1; then
                continue  # Service is running on its expected port, not a conflict
            fi
            echo -e " ${YELLOW}\u2717${NC}  Port ${port} in use (expected: ${name})"
            port_conflicts=$((port_conflicts + 1))
        fi
    done

    if [[ $port_conflicts -eq 0 ]]; then
        echo -e " ${GREEN}\u2713${NC}  No port conflicts detected"
    fi
    echo ""

    # ── Service health ──
    echo -e "${DIM}Services:${NC}"
    for entry in $(_services_by_tier "asc"); do
        local name port health_path
        name=$(_get_name "$entry")
        port=$(_get_port "$entry")
        health_path=$(_get_health "$entry")

        if curl -sf --max-time 2 "http://localhost:${port}${health_path}" >/dev/null 2>&1; then
            echo -e " ${GREEN}\u2713${NC}  ${name} :${port} — UP"
        else
            echo -e " ${RED}\u2717${NC}  ${name} :${port} — DOWN"
        fi
    done
    echo ""
}

# ── Main ─────────────────────────────────────────────────────────────────────

usage() {
    echo "Usage: ./jarvis <command> [service|--all] [options]"
    echo ""
    echo "Commands:"
    echo "  quickstart                  Full setup: init + start + LLM wizard"
    echo "  init                        Generate tokens, create .env files, start infra"
    echo "  start [service|--all]       Start service(s) in dependency order"
    echo "  stop [service|--all]        Stop service(s) in reverse order"
    echo "  restart [service|--all]     Stop then start"
    echo "  rebuild [service|--all]     Rebuild Docker images and restart"
    echo "  status                      Show all service statuses"
    echo "  health                      Hit health endpoints"
    echo "  logs <service>              Tail Docker logs for a service"
    echo "  llm-setup                   Run the LLM setup wizard"
    echo "  doctor                      Run system diagnostics"
    echo ""
    echo "Options:"
    echo "  --standalone                Start service with its own postgres (solo dev)"
    echo "  --no-network                Skip jarvis-net (distributed mode)"
    echo "  --force                     Force overwrite .env files during init"
    echo "  --custom                    Prompt for custom database names during init"
    echo ""
    echo "Services:"
    for entry in "${SERVICES[@]}"; do
        local name port tier
        name=$(_get_name "$entry")
        port=$(_get_port "$entry")
        tier=$(_get_tier "$entry")
        printf "  %-28s port %-5s tier %s\n" "$name" "$port" "$tier"
    done
}

# Parse global flags
FORCE_INIT=false
STANDALONE=false
CUSTOM_INIT=false
POSITIONAL=()

for arg in "$@"; do
    case "$arg" in
        --no-network)
            NETWORK_MODE="host"
            ;;
        --force)
            FORCE_INIT=true
            ;;
        --standalone)
            STANDALONE=true
            ;;
        --custom)
            CUSTOM_INIT=true
            ;;
        *)
            POSITIONAL+=("$arg")
            ;;
    esac
done

# Restore positional args
set -- "${POSITIONAL[@]}"

case "${1:-}" in
    quickstart)
        cmd_quickstart
        ;;
    init)
        cmd_init
        ;;
    start)
        if [[ "$STANDALONE" == true ]] && [[ "${2:-}" != "--all" ]]; then
            NETWORK_MODE="host"  # standalone skips jarvis-net
        fi
        cmd_start "${2:---all}" "${3:-}" "$STANDALONE"
        ;;
    stop)
        cmd_stop "${2:---all}" "$STANDALONE"
        ;;
    restart)
        cmd_stop "${2:---all}" "$STANDALONE"
        echo ""
        cmd_start "${2:---all}" "" "$STANDALONE"
        ;;
    rebuild)
        cmd_stop "${2:---all}" "$STANDALONE"
        echo ""
        cmd_start "${2:---all}" "--build" "$STANDALONE"
        ;;
    status)
        cmd_status
        ;;
    health)
        cmd_health
        ;;
    logs)
        if [[ -z "${2:-}" ]]; then
            echo -e "${RED}Usage: ./jarvis logs <service>${NC}"
            exit 1
        fi
        cmd_logs "$2"
        ;;
    llm-setup)
        _llm_wizard
        ;;
    doctor)
        cmd_doctor
        ;;
    *)
        usage
        ;;
esac
