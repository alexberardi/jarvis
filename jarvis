#!/usr/bin/env bash
# Jarvis service orchestration CLI
# Usage: ./jarvis <command> [service|--all] [options]
#
# Commands:
#   init                        Generate tokens, create .env files, start infra, run migrations
#   start [service|--all]       Start service(s) in dependency order
#   stop [service|--all]        Stop service(s) in reverse order
#   restart [service|--all]     Stop then start
#   rebuild [service|--all]     Rebuild Docker images and restart
#   status                      Show all service statuses
#   health                      Hit health endpoints
#   logs <service>              Tail Docker logs for a service
#   doctor                      Run system diagnostics
#
# Options:
#   --standalone                Start service with its own postgres (solo dev)
#   --no-network                Skip jarvis-net, use host.docker.internal (distributed mode)
#   --force                     Force overwrite .env files during init
#   --custom                    Prompt for custom database names during init

set -e

JARVIS_ROOT="$(cd "$(dirname "$0")" && pwd)"
PID_DIR="${HOME}/.jarvis/pids"
TOKEN_DIR="${HOME}/.jarvis"
TOKEN_FILE="${TOKEN_DIR}/tokens.env"
DB_FILE="${TOKEN_DIR}/databases.env"
DATA_SERVICES_DIR="${JARVIS_ROOT}/jarvis-data-services"
DATA_SERVICES_ENV="${DATA_SERVICES_DIR}/data-services.env"
mkdir -p "$PID_DIR"

# ── Network mode ───────────────────────────────────────────────────────────
NETWORK_MODE="${JARVIS_NETWORK_MODE:-bridge}"

# ── Service registry ────────────────────────────────────────────────────────
# Format: "name|port|tier|mode|health_path"
# mode: docker or local
# tier: startup order (0 = first)
SERVICES=(
    "jarvis-config-service|8013|0|docker|/health"
    "jarvis-auth|8007|1|docker|/health"
    "jarvis-logs|8006|1|docker|/health"
    "jarvis-command-center|8002|2|docker|/health"
    "jarvis-llm-proxy-api|8000|2|local|/health"
    "jarvis-tts|8009|3|docker|/health"
    "jarvis-whisper-api|8012|3|docker|/health"
    "jarvis-ocr-service|5009|3|docker|/health"
    "jarvis-recipes-server|8001|3|docker|/health"
    "jarvis-settings-server|8014|4|docker|/health"
    "jarvis-mcp|8011|4|docker|/health"
    "jarvis-admin|5173|5|npm|/"
)

# macOS overrides: GPU services run locally for Metal/Apple Vision
if [[ "$(uname -s)" == "Darwin" ]]; then
    for i in "${!SERVICES[@]}"; do
        case "${SERVICES[$i]}" in
            jarvis-llm-proxy-api*) SERVICES[$i]="jarvis-llm-proxy-api|8000|2|local|/health" ;;
            jarvis-ocr-service*)   SERVICES[$i]="jarvis-ocr-service|5009|3|local|/health" ;;
        esac
    done
fi

# ── Database mapping ─────────────────────────────────────────────────────────
# Consolidated database config: "service_name|db_var|default_db_name|env_vars"
# No associative arrays — bash 3.2 (macOS default) doesn't support them.
DB_ENTRIES=(
    "jarvis-config-service|DB_NAME_CONFIG|jarvis_config|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-auth|DB_NAME_AUTH|jarvis_auth|DATABASE_URL"
    "jarvis-logs|DB_NAME_LOGS|jarvis_logs|DATABASE_URL"
    "jarvis-command-center|DB_NAME_COMMAND_CENTER|jarvis_command_center|DB_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-llm-proxy-api|DB_NAME_LLM_PROXY|jarvis_llm_proxy|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-tts|DB_NAME_TTS|jarvis_tts|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-whisper-api|DB_NAME_WHISPER|jarvis_whisper|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-ocr-service|DB_NAME_OCR|jarvis_ocr|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-recipes-server|DB_NAME_RECIPES|jarvis_recipes|DATABASE_URL,MIGRATIONS_DATABASE_URL"
    "jarvis-mcp|DB_NAME_MCP|jarvis_mcp|DATABASE_URL"
)

# Lookup helpers for DB_ENTRIES (field positions: 1=service, 2=var, 3=default, 4=env_vars)
_db_entry_for_service() {
    local svc="$1"
    for entry in "${DB_ENTRIES[@]}"; do
        if [[ "${entry%%|*}" == "$svc" ]]; then
            echo "$entry"
            return 0
        fi
    done
    return 1
}

_db_field() { echo "$1" | cut -d'|' -f"$2"; }

# Services with migrations (in tier order, matches reset_all_databases.sh)
SERVICES_WITH_MIGRATIONS=(
    "jarvis-config-service"
    "jarvis-auth"
    "jarvis-logs"
    "jarvis-command-center"
    "jarvis-llm-proxy-api"
    "jarvis-tts"
    "jarvis-whisper-api"
    "jarvis-ocr-service"
    "jarvis-recipes-server"
    "jarvis-mcp"
)

# Services that use Redis
REDIS_SERVICES=(
    "jarvis-llm-proxy-api"
    "jarvis-ocr-service"
    "jarvis-recipes-server"
)

# ── Colors ───────────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m'

# ── Helpers ──────────────────────────────────────────────────────────────────

_parse_field() {
    local entry="$1" field="$2"
    echo "$entry" | cut -d'|' -f"$field"
}

_get_name()   { _parse_field "$1" 1; }
_get_port()   { _parse_field "$1" 2; }
_get_tier()   { _parse_field "$1" 3; }
_get_mode()   { _parse_field "$1" 4; }
_get_health() { _parse_field "$1" 5; }

_find_service() {
    local target="$1"
    for entry in "${SERVICES[@]}"; do
        local name
        name=$(_get_name "$entry")
        if [[ "$name" == "$target" ]]; then
            echo "$entry"
            return 0
        fi
    done
    return 1
}

_services_by_tier() {
    local order="$1"  # asc or desc
    local sorted
    if [[ "$order" == "desc" ]]; then
        sorted=$(for entry in "${SERVICES[@]}"; do
            echo "$(_get_tier "$entry")|$entry"
        done | sort -t'|' -k1 -rn)
    else
        sorted=$(for entry in "${SERVICES[@]}"; do
            echo "$(_get_tier "$entry")|$entry"
        done | sort -t'|' -k1 -n)
    fi

    while IFS= read -r line; do
        # Strip the leading tier field we added for sorting
        echo "${line#*|}"
    done <<< "$sorted"
}

_wait_for_health() {
    local name="$1" port="$2" health_path="$3" timeout="${4:-30}"
    local elapsed=0
    while (( elapsed < timeout )); do
        if curl -sf --max-time 2 "http://localhost:${port}${health_path}" >/dev/null 2>&1; then
            return 0
        fi
        sleep 1
        elapsed=$((elapsed + 1))
    done
    return 1
}

_find_compose_file() {
    local dir="$1"
    if [[ -f "$dir/docker-compose.dev.yaml" ]]; then
        echo "docker-compose.dev.yaml"
    elif [[ -f "$dir/docker-compose.yml" ]]; then
        echo "docker-compose.yml"
    elif [[ -f "$dir/docker-compose.yaml" ]]; then
        echo "docker-compose.yaml"
    fi
}

_get_compose_flags() {
    local dir="$1"
    local compose_file
    compose_file=$(_find_compose_file "$dir")
    [[ -z "$compose_file" ]] && return 1

    local flags="-f $compose_file"

    # In bridge mode, overlay the jarvis-net network
    if [[ "$NETWORK_MODE" == "bridge" ]] && [[ -f "${JARVIS_ROOT}/.jarvis-net-override.yaml" ]]; then
        flags="$flags -f ${JARVIS_ROOT}/.jarvis-net-override.yaml"
    fi

    echo "$flags"
}

_write_network_override() {
    # Ensure the jarvis-net Docker network exists
    docker network create jarvis-net >/dev/null 2>&1 || true

    # Write the jarvis-net overlay file (used in bridge mode)
    cat > "${JARVIS_ROOT}/.jarvis-net-override.yaml" << 'YAML'
# Auto-generated by ./jarvis CLI — do not edit
# Attaches services to the shared jarvis-net network
networks:
  default:
    name: jarvis-net
    external: true
YAML
}

_get_redis_password() {
    # Read redis password from data-services.env
    if [[ -f "$DATA_SERVICES_ENV" ]]; then
        grep "^REDIS_PASSWORD=" "$DATA_SERVICES_ENV" 2>/dev/null | cut -d= -f2-
    else
        echo "redis"  # default
    fi
}

# ── Database names ────────────────────────────────────────────────────────────

_write_db_defaults() {
    # Write databases.env with default names (skip if exists and not --force)
    if [[ -f "$DB_FILE" ]] && [[ "$FORCE_INIT" != true ]]; then
        echo -e "  ${GREEN}OK${NC}    Database names already configured (${DB_FILE})"
        return 0
    fi

    mkdir -p "$TOKEN_DIR"

    {
        echo "# Jarvis database names — generated by ./jarvis init"
        echo "# Edit these to use custom database names, then re-run ./jarvis init"
        for entry in "${DB_ENTRIES[@]}"; do
            local var default_val
            var=$(_db_field "$entry" 2)
            default_val=$(_db_field "$entry" 3)
            echo "${var}=${default_val}"
        done
    } > "$DB_FILE"

    chmod 600 "$DB_FILE"
    echo -e "  ${GREEN}OK${NC}    Database names → ${DB_FILE}"
}

_prompt_db_names() {
    # Interactive prompt for custom database names
    mkdir -p "$TOKEN_DIR"

    echo -e "  ${DIM}Database names (press Enter for defaults):${NC}"

    # Load existing values as defaults (if databases.env exists)
    if [[ -f "$DB_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$DB_FILE"
    fi

    local output=""
    for entry in "${DB_ENTRIES[@]}"; do
        local var label default_val current
        var=$(_db_field "$entry" 2)
        label=$(_db_field "$entry" 1)
        default_val=$(_db_field "$entry" 3)
        current="${!var:-${default_val}}"

        printf "    %-28s [%s]: " "$label" "$current"
        local user_input
        read -r user_input

        local value="${user_input:-$current}"
        # Validate: alphanumeric and underscore only
        if [[ ! "$value" =~ ^[A-Za-z0-9_]+$ ]]; then
            echo -e "    ${RED}Invalid name (alphanumeric/underscore only). Using default.${NC}"
            value="${default_val}"
        fi

        output+="${var}=${value}\n"
    done

    printf "# Jarvis database names — generated by ./jarvis init --custom\n" > "$DB_FILE"
    printf "%b" "$output" >> "$DB_FILE"

    chmod 600 "$DB_FILE"
    echo -e "  ${GREEN}OK${NC}    Custom database names → ${DB_FILE}"
}

_load_db_names() {
    # Load database names from databases.env, falling back to defaults
    if [[ -f "$DB_FILE" ]]; then
        # shellcheck disable=SC1090
        source "$DB_FILE"
    else
        # Use defaults (printf -v sets global variables, unlike declare in functions)
        for entry in "${DB_ENTRIES[@]}"; do
            local var default_val
            var=$(_db_field "$entry" 2)
            default_val=$(_db_field "$entry" 3)
            printf -v "$var" '%s' "$default_val"
        done
    fi
}

_get_db_name_for_service() {
    # Get the database name for a given service
    local service_name="$1"
    local db_entry
    db_entry=$(_db_entry_for_service "$service_name") || return 1

    local db_var
    db_var=$(_db_field "$db_entry" 2)

    # Return the value of that variable (loaded by _load_db_names)
    echo "${!db_var}"
}

# ── Init ─────────────────────────────────────────────────────────────────────

_generate_token() {
    openssl rand -hex 32
}

_generate_tokens() {
    if [[ -f "$TOKEN_FILE" ]] && [[ "$FORCE_INIT" != true ]]; then
        echo -e "  ${GREEN}OK${NC}    Tokens already exist (${TOKEN_FILE})"
        return 0
    fi

    mkdir -p "$TOKEN_DIR"

    local jwt_secret auth_admin_token config_admin_token
    local cc_admin_key model_service_token llm_internal_token

    jwt_secret=$(_generate_token)
    auth_admin_token=$(_generate_token)
    config_admin_token=$(_generate_token)
    cc_admin_key=$(_generate_token)
    model_service_token=$(_generate_token)
    llm_internal_token=$(_generate_token)

    cat > "$TOKEN_FILE" << EOF
# Jarvis shared tokens — generated by ./jarvis init
# Master copy. Individual .env files reference these values.
AUTH_SECRET_KEY=${jwt_secret}
JARVIS_AUTH_ADMIN_TOKEN=${auth_admin_token}
JARVIS_CONFIG_ADMIN_TOKEN=${config_admin_token}
ADMIN_API_KEY=${cc_admin_key}
MODEL_SERVICE_TOKEN=${model_service_token}
LLM_PROXY_INTERNAL_TOKEN=${llm_internal_token}
EOF

    chmod 600 "$TOKEN_FILE"
    echo -e "  ${GREEN}OK${NC}    Generated tokens → ${TOKEN_FILE}"
}

_load_tokens() {
    if [[ ! -f "$TOKEN_FILE" ]]; then
        echo -e "  ${RED}FAIL${NC}  No tokens file found. Run: ./jarvis init"
        exit 1
    fi
    # shellcheck disable=SC1090
    source "$TOKEN_FILE"
}

_sed_i() {
    # Cross-platform sed -i (macOS requires '' suffix, Linux does not)
    if [[ "$(uname -s)" == "Darwin" ]]; then
        sed -i '' "$@"
    else
        sed -i "$@"
    fi
}

_inject_env_var() {
    # Inject or replace a variable in a .env file
    local env_file="$1" var_name="$2" var_value="$3"

    if [[ ! -f "$env_file" ]]; then
        echo "${var_name}=${var_value}" >> "$env_file"
        return
    fi

    # Escape sed special characters in the replacement value (& \ |)
    local escaped_value
    escaped_value=$(printf '%s' "$var_value" | sed 's/[&\|]/\\&/g')

    if grep -q "^${var_name}=" "$env_file" 2>/dev/null; then
        # Replace existing value
        _sed_i "s|^${var_name}=.*|${var_name}=${escaped_value}|" "$env_file"
    elif grep -q "^# *${var_name}=" "$env_file" 2>/dev/null; then
        # Uncomment and set
        _sed_i "s|^# *${var_name}=.*|${var_name}=${escaped_value}|" "$env_file"
    else
        # Append
        echo "${var_name}=${var_value}" >> "$env_file"
    fi
}

_stamp_env_files() {
    _load_tokens
    _load_db_names

    for entry in "${SERVICES[@]}"; do
        local name mode
        name=$(_get_name "$entry")
        mode=$(_get_mode "$entry")
        local dir="${JARVIS_ROOT}/${name}"

        [[ ! -d "$dir" ]] && continue

        local env_file="${dir}/.env"
        local env_example="${dir}/.env.example"

        # Copy .env.example -> .env if .env doesn't exist (or --force)
        if [[ ! -f "$env_file" ]] || [[ "$FORCE_INIT" == true ]]; then
            if [[ -f "$env_example" ]]; then
                cp "$env_example" "$env_file"
            else
                touch "$env_file"
            fi
        fi

        # Docker services need host.docker.internal; local/npm use localhost
        local svc_host="host.docker.internal"
        if [[ "$mode" == "local" ]] || [[ "$mode" == "npm" ]]; then
            svc_host="localhost"
        fi

        # --- Shared tokens (all services) ---
        _inject_env_var "$env_file" "JARVIS_AUTH_ADMIN_TOKEN" "$JARVIS_AUTH_ADMIN_TOKEN"
        _inject_env_var "$env_file" "JARVIS_CONFIG_URL" "http://${svc_host}:8013"

        # --- Service-specific tokens ---
        case "$name" in
            jarvis-auth)
                _inject_env_var "$env_file" "AUTH_SECRET_KEY" "$AUTH_SECRET_KEY"
                ;;
            jarvis-config-service)
                _inject_env_var "$env_file" "JARVIS_CONFIG_ADMIN_TOKEN" "$JARVIS_CONFIG_ADMIN_TOKEN"
                ;;
            jarvis-settings-server)
                _inject_env_var "$env_file" "JARVIS_AUTH_SECRET_KEY" "$AUTH_SECRET_KEY"
                ;;
            jarvis-command-center)
                _inject_env_var "$env_file" "ADMIN_API_KEY" "$ADMIN_API_KEY"
                ;;
            jarvis-llm-proxy-api)
                _inject_env_var "$env_file" "MODEL_SERVICE_TOKEN" "$MODEL_SERVICE_TOKEN"
                _inject_env_var "$env_file" "LLM_PROXY_INTERNAL_TOKEN" "$LLM_PROXY_INTERNAL_TOKEN"
                ;;
        esac

        # --- Redis password (for services that use Redis) ---
        for redis_svc in "${REDIS_SERVICES[@]}"; do
            if [[ "$name" == "$redis_svc" ]]; then
                local redis_pw
                redis_pw=$(_get_redis_password)
                _inject_env_var "$env_file" "REDIS_PASSWORD" "$redis_pw"
                break
            fi
        done

        # --- Database URLs ---
        local db_entry=""
        db_entry=$(_db_entry_for_service "$name") || true
        if [[ -n "$db_entry" ]]; then
            local db_var env_vars db_name
            db_var=$(_db_field "$db_entry" 2)
            env_vars=$(_db_field "$db_entry" 4)
            db_name="${!db_var}"

            # Read postgres credentials from data-services.env (or defaults)
            local pg_user="postgres" pg_pass="postgres"
            if [[ -f "$DATA_SERVICES_ENV" ]]; then
                pg_user=$(grep "^POSTGRES_USER=" "$DATA_SERVICES_ENV" 2>/dev/null | cut -d= -f2-) || pg_user="postgres"
                pg_pass=$(grep "^POSTGRES_PASSWORD=" "$DATA_SERVICES_ENV" 2>/dev/null | cut -d= -f2-) || pg_pass="postgres"
            fi

            local db_url="postgresql+psycopg2://${pg_user}:${pg_pass}@${svc_host}:5432/${db_name}"
            local migrations_url="postgresql+psycopg2://${pg_user}:${pg_pass}@localhost:5432/${db_name}"

            IFS=',' read -ra var_names <<< "$env_vars"
            for var_name in "${var_names[@]}"; do
                if [[ "$var_name" == "MIGRATIONS_DATABASE_URL" ]]; then
                    _inject_env_var "$env_file" "$var_name" "$migrations_url"
                else
                    _inject_env_var "$env_file" "$var_name" "$db_url"
                fi
            done
        fi

        echo -e "  ${GREEN}OK${NC}    ${name}/.env"
    done
}

_start_infra() {
    echo -e "\n${DIM}Starting infrastructure (PostgreSQL + Redis + pgAdmin + MinIO)...${NC}"

    if [[ ! -d "$DATA_SERVICES_DIR" ]]; then
        echo -e "  ${RED}FAIL${NC}  jarvis-data-services directory not found"
        echo -e "  ${DIM}Run: git clone git@github.com:alexberardi/jarvis-data-services.git ${DATA_SERVICES_DIR}${NC}"
        exit 1
    fi

    local compose_output
    if ! compose_output=$(cd "$DATA_SERVICES_DIR" && docker compose --env-file data-services.env up -d 2>&1); then
        echo -e "  ${RED}FAIL${NC}  docker compose up failed for jarvis-data-services"
        echo -e "  ${DIM}${compose_output}${NC}"
        exit 1
    fi

    # Wait for postgres health
    local elapsed=0
    while (( elapsed < 30 )); do
        if docker exec jarvis-postgres pg_isready -U postgres >/dev/null 2>&1; then
            echo -e "  ${GREEN}OK${NC}    PostgreSQL ready"
            break
        fi
        sleep 1
        elapsed=$((elapsed + 1))
    done

    if (( elapsed >= 30 )); then
        echo -e "  ${RED}FAIL${NC}  PostgreSQL did not become ready in 30s"
        exit 1
    fi

    # Wait for redis health
    local redis_pw
    redis_pw=$(_get_redis_password)
    elapsed=0
    while (( elapsed < 15 )); do
        if docker exec jarvis-redis redis-cli -a "$redis_pw" ping >/dev/null 2>&1; then
            echo -e "  ${GREEN}OK${NC}    Redis ready"
            break
        fi
        sleep 1
        elapsed=$((elapsed + 1))
    done

    if (( elapsed >= 15 )); then
        echo -e "  ${YELLOW}WARN${NC}  Redis did not become ready in 15s (non-fatal)"
    fi
}

_create_databases() {
    echo -e "\n${DIM}Creating databases...${NC}"

    _load_db_names

    if [[ ! -f "${DATA_SERVICES_DIR}/create-db.sh" ]]; then
        echo -e "  ${YELLOW}WARN${NC}  create-db.sh not found in jarvis-data-services, skipping"
        return 0
    fi

    for entry in "${DB_ENTRIES[@]}"; do
        local var label db_name
        var=$(_db_field "$entry" 2)
        label=$(_db_field "$entry" 1)
        db_name="${!var}"

        if (cd "$DATA_SERVICES_DIR" && bash create-db.sh "$db_name" >/dev/null 2>&1); then
            echo -e "  ${GREEN}OK${NC}    ${db_name} (${label})"
        else
            # create-db.sh exits 0 for "already exists", so failure is real
            echo -e "  ${YELLOW}WARN${NC}  ${db_name} (${label}) — may already exist"
        fi
    done
}

_run_migrations() {
    echo -e "\n${DIM}Running migrations...${NC}"

    local success=0
    local failed=0

    for service in "${SERVICES_WITH_MIGRATIONS[@]}"; do
        local service_dir="${JARVIS_ROOT}/${service}"
        local migration_script="${service_dir}/apply_migrations.sh"

        if [[ ! -f "$migration_script" ]]; then
            echo -e "  ${YELLOW}SKIP${NC}  ${service} (no apply_migrations.sh)"
            continue
        fi

        if [[ ! -x "${service_dir}/.venv/bin/python" ]] && [[ ! -x "${service_dir}/venv/bin/python" ]]; then
            echo -e "  ${YELLOW}SKIP${NC}  ${service} (no .venv — run: cd ${service} && python3 -m venv .venv && .venv/bin/pip install -e .)"
            continue
        fi

        if (cd "$service_dir" && bash apply_migrations.sh >/dev/null 2>&1); then
            echo -e "  ${GREEN}OK${NC}    ${service}"
            success=$((success + 1))
        else
            echo -e "  ${RED}FAIL${NC}  ${service}"
            failed=$((failed + 1))
        fi
    done

    echo -e "\n  Migrations: ${GREEN}${success} OK${NC}, ${RED}${failed} failed${NC}"
}

_setup_local_services() {
    # Set up local-mode services (hardware detection + dependency install)
    local has_local=false
    for entry in "${SERVICES[@]}"; do
        local mode
        mode=$(_get_mode "$entry")
        [[ "$mode" == "local" ]] && has_local=true
    done
    [[ "$has_local" != "true" ]] && { echo -e "  ${DIM}No local-mode services to set up${NC}"; return 0; }

    for entry in "${SERVICES[@]}"; do
        local name mode dir
        name=$(_get_name "$entry")
        mode=$(_get_mode "$entry")
        dir="${JARVIS_ROOT}/${name}"

        [[ "$mode" != "local" ]] && continue
        [[ ! -d "$dir" ]] && continue

        # Services with setup.sh have sophisticated setup (hardware detection + run.sh --setup)
        if [[ -f "$dir/setup.sh" ]]; then
            # Run hardware setup wizard if needed (auto-detect, non-interactive)
            if [[ ! -f "$dir/.setup_config" ]]; then
                echo -ne "  ${BLUE}...${NC}   ${name} (detecting hardware)"
                if (cd "$dir" && bash setup.sh --auto >/dev/null 2>&1); then
                    echo -e "\r  ${GREEN}OK${NC}    ${name} hardware configured\033[K"
                else
                    echo -e "\r  ${YELLOW}WARN${NC}  ${name} hardware setup failed (run manually: cd ${name} && bash setup.sh)\033[K"
                fi
            fi

            # Install dependencies via run.sh --setup (venv + deps + acceleration libs)
            if [[ -f "$dir/run.sh" ]]; then
                echo -ne "  ${BLUE}...${NC}   ${name} (installing dependencies — may take a few minutes)"
                local setup_output
                if setup_output=$(cd "$dir" && AUTO_SETUP=true bash run.sh --setup 2>&1); then
                    echo -e "\r  ${GREEN}OK${NC}    ${name} dependencies installed\033[K"
                else
                    echo -e "\r  ${YELLOW}WARN${NC}  ${name} dependency install had issues\033[K"
                    echo "$setup_output" | tail -5 | while IFS= read -r line; do
                        echo -e "        ${DIM}${line}${NC}"
                    done
                    echo -e "        ${DIM}Run manually: cd ${name} && bash run.sh --rebuild${NC}"
                fi
            fi
        else
            # Check if it's a Poetry project (pre-install so start is fast)
            if grep -q 'poetry' "$dir/pyproject.toml" 2>/dev/null && command -v poetry >/dev/null 2>&1; then
                echo -ne "  ${BLUE}...${NC}   ${name} (installing dependencies via Poetry)"
                local poetry_output
                if poetry_output=$(cd "$dir" && poetry install 2>&1); then
                    echo -e "\r  ${GREEN}OK${NC}    ${name} dependencies installed\033[K"
                else
                    echo -e "\r  ${YELLOW}WARN${NC}  ${name} poetry install had issues\033[K"
                    echo "$poetry_output" | tail -3 | while IFS= read -r line; do
                        echo -e "        ${DIM}${line}${NC}"
                    done
                fi
                # Also create .venv for migration scripts (apply_migrations.sh uses .venv/bin/python)
                _ensure_venv "$dir" "$name" 2>/dev/null || true
            else
                # Basic venv setup for simpler local services
                _ensure_venv "$dir" "$name" || echo -e "  ${YELLOW}WARN${NC}  ${name} venv setup failed"
            fi
        fi
    done
}

cmd_init() {
    echo -e "${BOLD}JARVIS INIT${NC}"
    echo ""

    echo -e "${DIM}Step 1: Generate tokens${NC}"
    _generate_tokens

    echo -e "\n${DIM}Step 2: Configure database names${NC}"
    if [[ "$CUSTOM_INIT" == true ]]; then
        _prompt_db_names
    else
        _write_db_defaults
    fi

    echo -e "\n${DIM}Step 3: Stamp .env files${NC}"
    _stamp_env_files

    echo -e "\n${DIM}Step 4: Set up local services${NC}"
    _setup_local_services

    echo ""
    _start_infra

    echo ""
    _create_databases

    echo ""
    _run_migrations

    echo ""
    echo -e "${BOLD}Init complete.${NC}"
    echo -e "  Next: ${CYAN}./jarvis start --all${NC}"
}

# ── Start ────────────────────────────────────────────────────────────────────

_ensure_venv() {
    # Ensure .venv exists and deps are installed for a local-mode service
    local dir="$1" name="$2"
    local venv_dir="${dir}/.venv"

    if [[ -x "${venv_dir}/bin/python" ]]; then
        return 0
    fi

    # Also accept legacy venv/ directory
    if [[ -x "${dir}/venv/bin/python" ]]; then
        return 0
    fi

    echo ""
    echo -ne "        ${DIM}creating .venv for ${name}...${NC}"
    if ! python3 -m venv "$venv_dir" 2>/dev/null; then
        echo -e "\r        ${RED}failed to create .venv${NC}     "
        return 1
    fi

    echo -e "\r        ${DIM}installing deps for ${name}...${NC}  "
    local pip_output

    # Prefer requirements.txt (works with pip directly); fall back to pyproject.toml
    if [[ -f "${dir}/requirements.txt" ]]; then
        if ! pip_output=$("${venv_dir}/bin/pip" install -q -r "${dir}/requirements.txt" 2>&1); then
            echo -e "        ${RED}pip install failed:${NC}"
            echo "$pip_output" | tail -5 | while IFS= read -r line; do
                echo -e "        ${DIM}${line}${NC}"
            done
            return 1
        fi
    elif [[ -f "${dir}/pyproject.toml" ]]; then
        if ! pip_output=$("${venv_dir}/bin/pip" install -q -e "$dir" 2>&1); then
            echo -e "        ${RED}pip install failed:${NC}"
            echo "$pip_output" | tail -5 | while IFS= read -r line; do
                echo -e "        ${DIM}${line}${NC}"
            done
            return 1
        fi
    fi

    echo -e "        ${GREEN}OK${NC}    .venv ready"
    return 0
}

_start_one() {
    local entry="$1" build_flag="${2:-}" standalone="${3:-false}"
    local name port tier mode
    name=$(_get_name "$entry")
    port=$(_get_port "$entry")
    tier=$(_get_tier "$entry")
    mode=$(_get_mode "$entry")

    local dir="${JARVIS_ROOT}/${name}"
    if [[ ! -d "$dir" ]]; then
        echo -e "  ${YELLOW}SKIP${NC}  ${name} (directory not found)"
        return 0
    fi

    # Check if already running
    if curl -sf --max-time 2 "http://localhost:${port}$(_get_health "$entry")" >/dev/null 2>&1; then
        echo -e "  ${GREEN}UP${NC}    ${name} :${port}"
        return 0
    fi

    echo -ne "  ${BLUE}...${NC}   ${name} :${port}"

    case "$mode" in
        docker)
            local compose_file=""
            compose_file=$(_find_compose_file "$dir")

            if [[ -z "$compose_file" ]]; then
                echo -e "\r  ${RED}FAIL${NC}  ${name} (no docker-compose file found)"
                return 1
            fi

            local env_flag=""
            [[ -f "$dir/.env" ]] && env_flag="--env-file .env"

            local compose_flags=""
            if [[ "$standalone" == true ]]; then
                # Standalone: use profile, no network overlay
                compose_flags="--profile standalone -f $compose_file"
            else
                compose_flags=$(_get_compose_flags "$dir") || {
                    echo -e "\r  ${RED}FAIL${NC}  ${name} (no docker-compose file found)"
                    return 1
                }
            fi

            local compose_output
            if ! compose_output=$(cd "$dir" && docker compose $env_flag $compose_flags up -d $build_flag 2>&1); then
                echo -e "\r  ${RED}FAIL${NC}  ${name} (docker compose up failed)"
                echo -e "  ${DIM}${compose_output}${NC}"
                return 1
            fi
            ;;
        local)
            if [[ -f "$dir/run.sh" ]]; then
                # run.sh handles its own venv creation + deps (set up during init)
                (cd "$dir" && AUTO_SETUP=true exec bash run.sh >/dev/null 2>&1) &
                echo $! > "${PID_DIR}/${name}.pid"
            else
                echo -e "\r  ${RED}FAIL${NC}  ${name} (no run.sh found)"
                return 1
            fi
            ;;
        npm)
            if [[ -f "$dir/package.json" ]]; then
                # Source nvm for correct Node.js version
                local nvm_init="${HOME}/.nvm/nvm.sh"
                local nvm_cmd=""
                if [[ -f "$nvm_init" ]]; then
                    nvm_cmd="source $nvm_init && nvm use default --silent &&"
                fi

                # Load .env from service root so backend gets env vars like AUTH_URL
                local env_export=""
                if [[ -f "$dir/.env" ]]; then
                    env_export="set -a && source $dir/.env && set +a &&"
                fi

                # Start backend server if it exists (e.g. jarvis-admin/server)
                if [[ -f "$dir/server/package.json" ]]; then
                    (cd "$dir/server" && eval "$env_export $nvm_cmd exec npm run dev" >/dev/null 2>&1) &
                    echo $! > "${PID_DIR}/${name}-server.pid"
                fi

                # Start frontend dev server
                (cd "$dir" && eval "$nvm_cmd exec npm run dev" >/dev/null 2>&1) &
                echo $! > "${PID_DIR}/${name}.pid"
            else
                echo -e "\r  ${RED}FAIL${NC}  ${name} (no package.json found)"
                return 1
            fi
            ;;
    esac

    echo -e "\r  ${GREEN}START${NC} ${name} :${port}"
}

_start_tier() {
    local target_tier="$1" build_flag="${2:-}"
    for entry in "${SERVICES[@]}"; do
        local tier
        tier=$(_get_tier "$entry")
        if [[ "$tier" == "$target_tier" ]]; then
            _start_one "$entry" "$build_flag"
        fi
    done
}

_auto_register() {
    # Auto-register all services with config-service using admin token
    local token_file="${JARVIS_ROOT}/jarvis-config-service/.env"
    local token=""

    if [[ -f "$token_file" ]]; then
        token=$(grep "^JARVIS_AUTH_ADMIN_TOKEN=" "$token_file" 2>/dev/null | cut -d= -f2-)
    fi

    if [[ -z "$token" ]]; then
        echo -e "  ${YELLOW}SKIP${NC}  Auto-registration (no JARVIS_AUTH_ADMIN_TOKEN found)"
        return 0
    fi

    # Wait for config-service and auth to be ready
    if ! _wait_for_health "jarvis-config-service" 8013 "/health" 10; then
        echo -e "  ${YELLOW}SKIP${NC}  Auto-registration (config-service not ready)"
        return 0
    fi
    if ! _wait_for_health "jarvis-auth" 8007 "/health" 10; then
        echo -e "  ${YELLOW}SKIP${NC}  Auto-registration (jarvis-auth not ready)"
        return 0
    fi

    # Build services JSON array
    local services_json="["
    local first=true
    for entry in "${SERVICES[@]}"; do
        local name port
        name=$(_get_name "$entry")
        port=$(_get_port "$entry")

        # Skip config-service (it IS the registry) and admin (no backend registration needed)
        [[ "$name" == "jarvis-config-service" ]] && continue
        [[ "$name" == "jarvis-admin" ]] && continue

        if [[ "$first" == true ]]; then
            first=false
        else
            services_json+=","
        fi
        services_json+="{\"name\":\"${name}\",\"host\":\"localhost\",\"port\":${port}}"
    done
    services_json+="]"

    local response
    response=$(curl -s -w "\n%{http_code}" -X POST "http://localhost:8013/v1/services/register" \
        -H "X-Jarvis-Admin-Token: ${token}" \
        -H "Content-Type: application/json" \
        -d "{\"services\":${services_json},\"base_path\":\"${JARVIS_ROOT}\"}" 2>/dev/null)

    local http_code
    http_code=$(echo "$response" | tail -1)

    if [[ "$http_code" == "200" ]]; then
        echo -e "  ${GREEN}OK${NC}    Services registered with config-service"
    else
        echo -e "  ${YELLOW}WARN${NC}  Auto-registration returned HTTP ${http_code} (services may need manual registration)"
    fi
}

cmd_start() {
    local target="$1" build_flag="${2:-}" standalone="${3:-false}"

    echo -e "${BOLD}JARVIS START${NC}"
    echo ""

    if [[ "$target" == "--all" ]]; then
        # Ensure infra is running (unless distributed mode)
        if [[ "$NETWORK_MODE" == "bridge" ]]; then
            _write_network_override

            # Start infra if not already running
            if ! docker exec jarvis-postgres pg_isready -U postgres >/dev/null 2>&1; then
                echo -e "${DIM}Starting infrastructure...${NC}"
                if [[ -d "$DATA_SERVICES_DIR" ]]; then
                    (cd "$DATA_SERVICES_DIR" && docker compose --env-file data-services.env up -d 2>&1) | sed 's/^/  /' || true
                fi

                local elapsed=0
                while (( elapsed < 30 )); do
                    if docker exec jarvis-postgres pg_isready -U postgres >/dev/null 2>&1; then
                        echo -e "  ${GREEN}OK${NC}    Infrastructure ready"
                        break
                    fi
                    sleep 1
                    elapsed=$((elapsed + 1))
                done
                echo ""
            fi
        fi

        # Build images first when --build is set (separate from start)
        if [[ -n "$build_flag" ]]; then
            echo -e "${DIM}Building images...${NC}"
            local build_failed=false
            for entry in "${SERVICES[@]}"; do
                local bmode bname bdir
                bmode=$(_get_mode "$entry")
                [[ "$bmode" != "docker" ]] && continue
                bname=$(_get_name "$entry")
                bdir="${JARVIS_ROOT}/${bname}"
                [[ ! -d "$bdir" ]] && continue

                local bcompose_file benv_flag bcompose_flags
                bcompose_file=$(_find_compose_file "$bdir")
                [[ -z "$bcompose_file" ]] && continue
                benv_flag=""
                [[ -f "$bdir/.env" ]] && benv_flag="--env-file .env"
                if [[ "$standalone" == true ]]; then
                    bcompose_flags="--profile standalone -f $bcompose_file"
                else
                    bcompose_flags=$(_get_compose_flags "$bdir") || continue
                fi

                echo -ne "  ${BLUE}...${NC}   ${bname}"
                local build_output
                if ! build_output=$(cd "$bdir" && docker compose $benv_flag $bcompose_flags build 2>&1); then
                    echo -e "\r  ${RED}FAIL${NC}  ${bname}"
                    echo "$build_output" | tail -5 | while IFS= read -r line; do
                        echo -e "        ${DIM}${line}${NC}"
                    done
                    build_failed=true
                else
                    echo -e "\r  ${GREEN}OK${NC}    ${bname}"
                fi
            done
            echo ""

            if [[ "$build_failed" == true ]]; then
                echo -e "${YELLOW}Some images failed to build. Starting available services...${NC}"
                echo ""
            fi

            # Clear build_flag so _start_one uses plain 'up -d'
            build_flag=""
        fi

        # Get unique tiers in order
        local tiers
        tiers=$(for entry in "${SERVICES[@]}"; do _get_tier "$entry"; done | sort -un)

        for tier in $tiers; do
            echo -e "${DIM}Tier ${tier}${NC}"
            _start_tier "$tier" "$build_flag"

            # Wait for health of tier before moving to next
            local all_healthy=true
            for entry in "${SERVICES[@]}"; do
                local t
                t=$(_get_tier "$entry")
                if [[ "$t" == "$tier" ]]; then
                    local name port health_path dir
                    name=$(_get_name "$entry")
                    port=$(_get_port "$entry")
                    health_path=$(_get_health "$entry")
                    dir="${JARVIS_ROOT}/${name}"
                    [[ ! -d "$dir" ]] && continue
                    if ! _wait_for_health "$name" "$port" "$health_path" 60; then
                        echo -e "  ${YELLOW}WAIT${NC}  ${name} (health check timeout)"
                        all_healthy=false
                    fi
                fi
            done

            # Auto-register after tier 1 (config-service + auth are up)
            if [[ "$tier" == "1" ]]; then
                _auto_register
            fi

            echo ""
        done
    else
        local entry
        entry=$(_find_service "$target") || {
            echo -e "${RED}Unknown service: ${target}${NC}"
            echo "Available: $(for e in "${SERVICES[@]}"; do _get_name "$e"; done | tr '\n' ' ')"
            exit 1
        }
        _start_one "$entry" "$build_flag" "$standalone"
    fi
}

# ── Stop ─────────────────────────────────────────────────────────────────────

_stop_one() {
    local entry="$1" standalone="${2:-false}"
    local name port mode
    name=$(_get_name "$entry")
    port=$(_get_port "$entry")
    mode=$(_get_mode "$entry")

    local dir="${JARVIS_ROOT}/${name}"
    if [[ ! -d "$dir" ]]; then
        return 0
    fi

    case "$mode" in
        docker)
            local compose_file=""
            compose_file=$(_find_compose_file "$dir")

            if [[ -n "$compose_file" ]]; then
                local env_flag=""
                [[ -f "$dir/.env" ]] && env_flag="--env-file .env"

                local compose_flags=""
                if [[ "$standalone" == true ]]; then
                    compose_flags="--profile standalone -f $compose_file"
                else
                    compose_flags=$(_get_compose_flags "$dir") || compose_flags="-f $compose_file"
                fi

                (cd "$dir" && docker compose $env_flag $compose_flags down >/dev/null 2>&1) || true
            fi
            ;;
        local|npm)
            # Kill backend server PID if exists (e.g. jarvis-admin-server)
            if [[ -f "${PID_DIR}/${name}-server.pid" ]]; then
                local server_pid
                server_pid=$(cat "${PID_DIR}/${name}-server.pid")
                kill "$server_pid" 2>/dev/null || true
                rm -f "${PID_DIR}/${name}-server.pid"
            fi
            if [[ -f "${PID_DIR}/${name}.pid" ]]; then
                local pid
                pid=$(cat "${PID_DIR}/${name}.pid")
                kill "$pid" 2>/dev/null || true
                rm -f "${PID_DIR}/${name}.pid"
            fi
            ;;
    esac

    echo -e "  ${RED}STOP${NC}  ${name}"
}

cmd_stop() {
    local target="$1" standalone="${2:-false}"

    echo -e "${BOLD}JARVIS STOP${NC}"
    echo ""

    if [[ "$target" == "--all" ]]; then
        # Stop in reverse tier order
        local tiers
        tiers=$(for entry in "${SERVICES[@]}"; do _get_tier "$entry"; done | sort -unr)
        for tier in $tiers; do
            for entry in "${SERVICES[@]}"; do
                local t
                t=$(_get_tier "$entry")
                if [[ "$t" == "$tier" ]]; then
                    _stop_one "$entry" "$standalone"
                fi
            done
        done

        # Stop infrastructure (only in bridge mode, not standalone)
        if [[ "$NETWORK_MODE" == "bridge" ]] && [[ "$standalone" != true ]]; then
            echo ""
            echo -e "${DIM}Stopping infrastructure...${NC}"
            if [[ -d "$DATA_SERVICES_DIR" ]]; then
                (cd "$DATA_SERVICES_DIR" && docker compose --env-file data-services.env down >/dev/null 2>&1) || true
            fi
            echo -e "  ${RED}STOP${NC}  PostgreSQL + Redis + pgAdmin + MinIO"
        fi
    else
        local entry
        entry=$(_find_service "$target") || {
            echo -e "${RED}Unknown service: ${target}${NC}"
            exit 1
        }
        _stop_one "$entry" "$standalone"
    fi
}

# ── Status ───────────────────────────────────────────────────────────────────

cmd_status() {
    echo ""
    echo -e "${BOLD}JARVIS SERVICE STATUS${NC}"
    printf '%.0s\u2550' {1..55}
    echo ""
    printf "%-28s %-6s %-5s %s\n" "SERVICE" "PORT" "TIER" "STATUS"
    printf '%.0s\u2500' {1..55}
    echo ""

    for entry in $(_services_by_tier "asc"); do
        local name port tier health_path
        name=$(_get_name "$entry")
        port=$(_get_port "$entry")
        tier=$(_get_tier "$entry")
        health_path=$(_get_health "$entry")

        local status_str
        if curl -sf --max-time 2 "http://localhost:${port}${health_path}" >/dev/null 2>&1; then
            status_str="${GREEN}UP${NC}"
        else
            status_str="${RED}DOWN${NC}"
        fi

        printf "%-28s %-6s %-5s " "$name" "$port" "$tier"
        echo -e "$status_str"
    done

    echo ""
}

# ── Health ───────────────────────────────────────────────────────────────────

cmd_health() {
    echo ""
    echo -e "${BOLD}JARVIS HEALTH CHECK${NC}"
    printf '%.0s\u2550' {1..65}
    echo ""

    for entry in $(_services_by_tier "asc"); do
        local name port health_path
        name=$(_get_name "$entry")
        port=$(_get_port "$entry")
        health_path=$(_get_health "$entry")

        local url="http://localhost:${port}${health_path}"
        local response
        response=$(curl -sf --max-time 3 "$url" 2>/dev/null) && {
            echo -e "${GREEN}OK${NC}    ${name}  ${DIM}${response}${NC}"
        } || {
            echo -e "${RED}FAIL${NC}  ${name}  ${DIM}${url}${NC}"
        }
    done

    echo ""
}

# ── Logs ─────────────────────────────────────────────────────────────────────

cmd_logs() {
    local target="$1"

    local entry
    entry=$(_find_service "$target") || {
        echo -e "${RED}Unknown service: ${target}${NC}"
        exit 1
    }

    local name dir mode
    name=$(_get_name "$entry")
    dir="${JARVIS_ROOT}/${name}"
    mode=$(_get_mode "$entry")

    if [[ "$mode" == "docker" ]]; then
        local compose_file=""
        compose_file=$(_find_compose_file "$dir")

        if [[ -n "$compose_file" ]]; then
            local env_flag=""
            [[ -f "$dir/.env" ]] && env_flag="--env-file .env"
            (cd "$dir" && docker compose $env_flag -f "$compose_file" logs -f --tail 100)
        else
            echo -e "${RED}No docker-compose file found for ${name}${NC}"
            exit 1
        fi
    else
        echo -e "${YELLOW}${name} runs locally - check its terminal output${NC}"
    fi
}

# ── Doctor ───────────────────────────────────────────────────────────────────

_check_cmd() {
    local name="$1" cmd="$2"
    local version
    if version=$(eval "$cmd" 2>/dev/null | head -1); then
        echo -e " ${GREEN}\u2713${NC}  ${name} ${DIM}${version}${NC}"
        return 0
    else
        echo -e " ${RED}\u2717${NC}  ${name} — not found"
        return 1
    fi
}

cmd_doctor() {
    echo ""
    echo -e "${BOLD}JARVIS SYSTEM CHECK${NC}"
    printf '%.0s\u2550' {1..55}
    echo ""

    # ── Prerequisites ──
    echo -e "${DIM}Prerequisites:${NC}"
    _check_cmd "Docker" "docker --version" || true
    _check_cmd "Node.js" "node --version" || true
    _check_cmd "Python" "python3 --version" || true
    _check_cmd "OpenSSL" "openssl version" || true
    echo ""

    # ── Infrastructure ──
    echo -e "${DIM}Infrastructure:${NC}"
    if docker exec jarvis-postgres pg_isready -U postgres >/dev/null 2>&1; then
        echo -e " ${GREEN}\u2713${NC}  PostgreSQL reachable (jarvis-postgres)"
    else
        echo -e " ${RED}\u2717${NC}  PostgreSQL not reachable (run: ./jarvis init)"
    fi

    local redis_pw
    redis_pw=$(_get_redis_password)
    if docker exec jarvis-redis redis-cli -a "$redis_pw" ping >/dev/null 2>&1; then
        echo -e " ${GREEN}\u2713${NC}  Redis reachable (jarvis-redis)"
    else
        echo -e " ${RED}\u2717${NC}  Redis not reachable (run: ./jarvis init)"
    fi

    # pgAdmin check (nice-to-have)
    if curl -sf --max-time 2 "http://localhost:5050" >/dev/null 2>&1; then
        echo -e " ${GREEN}\u2713${NC}  pgAdmin reachable (:5050)"
    else
        echo -e " ${DIM}\u2717${NC}  pgAdmin not reachable (:5050)"
    fi

    # MinIO check (nice-to-have)
    if curl -sf --max-time 2 "http://localhost:9000/minio/health/live" >/dev/null 2>&1; then
        echo -e " ${GREEN}\u2713${NC}  MinIO reachable (:9000)"
    else
        echo -e " ${DIM}\u2717${NC}  MinIO not reachable (:9000)"
    fi
    echo ""

    # ── Configuration ──
    echo -e "${DIM}Configuration:${NC}"
    local env_present=0
    local env_missing=0
    local missing_list=""

    for entry in "${SERVICES[@]}"; do
        local name
        name=$(_get_name "$entry")
        local dir="${JARVIS_ROOT}/${name}"
        [[ ! -d "$dir" ]] && continue

        if [[ -f "${dir}/.env" ]]; then
            env_present=$((env_present + 1))
        else
            env_missing=$((env_missing + 1))
            missing_list="${missing_list} ${name}"
        fi
    done

    local total=$(( env_present + env_missing ))
    if [[ $env_missing -eq 0 ]]; then
        echo -e " ${GREEN}\u2713${NC}  .env files present (${env_present}/${total})"
    else
        echo -e " ${YELLOW}\u2717${NC}  .env files: ${env_present}/${total} present"
        for m in $missing_list; do
            echo -e "     ${RED}missing:${NC} ${m}/.env"
        done
    fi

    # Database names config check
    if [[ -f "$DB_FILE" ]]; then
        echo -e " ${GREEN}\u2713${NC}  Database names configured (${DB_FILE})"
    else
        echo -e " ${YELLOW}\u2717${NC}  No database names file (run: ./jarvis init)"
    fi

    # Token consistency checks
    if [[ -f "$TOKEN_FILE" ]]; then
        echo -e " ${GREEN}\u2713${NC}  Master tokens file exists (${TOKEN_FILE})"

        # Check JARVIS_AUTH_ADMIN_TOKEN consistency
        # shellcheck disable=SC1090
        source "$TOKEN_FILE"
        local token_mismatches=0

        for entry in "${SERVICES[@]}"; do
            local name
            name=$(_get_name "$entry")
            local env_file="${JARVIS_ROOT}/${name}/.env"
            [[ ! -f "$env_file" ]] && continue

            local env_token
            env_token=$(grep "^JARVIS_AUTH_ADMIN_TOKEN=" "$env_file" 2>/dev/null | cut -d= -f2-)
            if [[ -n "$env_token" ]] && [[ "$env_token" != "$JARVIS_AUTH_ADMIN_TOKEN" ]]; then
                echo -e "     ${RED}mismatch:${NC} ${name} JARVIS_AUTH_ADMIN_TOKEN differs from master"
                token_mismatches=$((token_mismatches + 1))
            fi
        done

        if [[ $token_mismatches -eq 0 ]]; then
            echo -e " ${GREEN}\u2713${NC}  JARVIS_AUTH_ADMIN_TOKEN consistent across services"
        fi

        # Check JWT secret consistency (auth <-> settings-server)
        local auth_secret="" settings_secret=""
        [[ -f "${JARVIS_ROOT}/jarvis-auth/.env" ]] && \
            auth_secret=$(grep "^AUTH_SECRET_KEY=" "${JARVIS_ROOT}/jarvis-auth/.env" 2>/dev/null | cut -d= -f2-)
        [[ -f "${JARVIS_ROOT}/jarvis-settings-server/.env" ]] && \
            settings_secret=$(grep "^JARVIS_AUTH_SECRET_KEY=" "${JARVIS_ROOT}/jarvis-settings-server/.env" 2>/dev/null | cut -d= -f2-)

        if [[ -n "$auth_secret" ]] && [[ -n "$settings_secret" ]]; then
            if [[ "$auth_secret" == "$settings_secret" ]]; then
                echo -e " ${GREEN}\u2713${NC}  JWT secret consistent (jarvis-auth \u2194 jarvis-settings-server)"
            else
                echo -e " ${RED}\u2717${NC}  JWT secret MISMATCH (jarvis-auth AUTH_SECRET_KEY \u2260 jarvis-settings-server JARVIS_AUTH_SECRET_KEY)"
            fi
        fi
    else
        echo -e " ${YELLOW}\u2717${NC}  No master tokens file (run: ./jarvis init)"
    fi
    echo ""

    # ── Port conflicts ──
    echo -e "${DIM}Ports:${NC}"
    local port_conflicts=0
    for entry in "${SERVICES[@]}"; do
        local name port
        name=$(_get_name "$entry")
        port=$(_get_port "$entry")

        local pid_info
        pid_info=$(ss -tlnp 2>/dev/null | grep ":${port} " | head -1)

        if [[ -n "$pid_info" ]]; then
            # Port is in use — check if it's the expected service (not a conflict)
            if curl -sf --max-time 2 "http://localhost:${port}$(_get_health "$entry")" >/dev/null 2>&1; then
                continue  # Service is running on its expected port, not a conflict
            fi
            echo -e " ${YELLOW}\u2717${NC}  Port ${port} in use (expected: ${name})"
            port_conflicts=$((port_conflicts + 1))
        fi
    done

    if [[ $port_conflicts -eq 0 ]]; then
        echo -e " ${GREEN}\u2713${NC}  No port conflicts detected"
    fi
    echo ""

    # ── Service health ──
    echo -e "${DIM}Services:${NC}"
    for entry in $(_services_by_tier "asc"); do
        local name port health_path
        name=$(_get_name "$entry")
        port=$(_get_port "$entry")
        health_path=$(_get_health "$entry")

        if curl -sf --max-time 2 "http://localhost:${port}${health_path}" >/dev/null 2>&1; then
            echo -e " ${GREEN}\u2713${NC}  ${name} :${port} — UP"
        else
            echo -e " ${RED}\u2717${NC}  ${name} :${port} — DOWN"
        fi
    done
    echo ""
}

# ── Main ─────────────────────────────────────────────────────────────────────

usage() {
    echo "Usage: ./jarvis <command> [service|--all] [options]"
    echo ""
    echo "Commands:"
    echo "  init                        Generate tokens, create .env files, start infra"
    echo "  start [service|--all]       Start service(s) in dependency order"
    echo "  stop [service|--all]        Stop service(s) in reverse order"
    echo "  restart [service|--all]     Stop then start"
    echo "  rebuild [service|--all]     Rebuild Docker images and restart"
    echo "  status                      Show all service statuses"
    echo "  health                      Hit health endpoints"
    echo "  logs <service>              Tail Docker logs for a service"
    echo "  doctor                      Run system diagnostics"
    echo ""
    echo "Options:"
    echo "  --standalone                Start service with its own postgres (solo dev)"
    echo "  --no-network                Skip jarvis-net (distributed mode)"
    echo "  --force                     Force overwrite .env files during init"
    echo "  --custom                    Prompt for custom database names during init"
    echo ""
    echo "Services:"
    for entry in "${SERVICES[@]}"; do
        local name port tier
        name=$(_get_name "$entry")
        port=$(_get_port "$entry")
        tier=$(_get_tier "$entry")
        printf "  %-28s port %-5s tier %s\n" "$name" "$port" "$tier"
    done
}

# Parse global flags
FORCE_INIT=false
STANDALONE=false
CUSTOM_INIT=false
POSITIONAL=()

for arg in "$@"; do
    case "$arg" in
        --no-network)
            NETWORK_MODE="host"
            ;;
        --force)
            FORCE_INIT=true
            ;;
        --standalone)
            STANDALONE=true
            ;;
        --custom)
            CUSTOM_INIT=true
            ;;
        *)
            POSITIONAL+=("$arg")
            ;;
    esac
done

# Restore positional args
set -- "${POSITIONAL[@]}"

case "${1:-}" in
    init)
        cmd_init
        ;;
    start)
        if [[ "$STANDALONE" == true ]] && [[ "${2:-}" != "--all" ]]; then
            NETWORK_MODE="host"  # standalone skips jarvis-net
        fi
        cmd_start "${2:---all}" "${3:-}" "$STANDALONE"
        ;;
    stop)
        cmd_stop "${2:---all}" "$STANDALONE"
        ;;
    restart)
        cmd_stop "${2:---all}" "$STANDALONE"
        echo ""
        cmd_start "${2:---all}" "" "$STANDALONE"
        ;;
    rebuild)
        cmd_stop "${2:---all}" "$STANDALONE"
        echo ""
        cmd_start "${2:---all}" "--build" "$STANDALONE"
        ;;
    status)
        cmd_status
        ;;
    health)
        cmd_health
        ;;
    logs)
        if [[ -z "${2:-}" ]]; then
            echo -e "${RED}Usage: ./jarvis logs <service>${NC}"
            exit 1
        fi
        cmd_logs "$2"
        ;;
    doctor)
        cmd_doctor
        ;;
    *)
        usage
        ;;
esac
